<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Building the Transformer from Scratch</title>

    <!-- Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link
        href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;700&family=Source+Sans+3:wght@400;600;700&family=Space+Grotesk:wght@400;600;700&display=swap"
        rel="stylesheet">

    <!-- Libraries -->
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <link rel="stylesheet"
        href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <!-- MathJax Config -->
    <script>
        MathJax = {
            tex: {
                inlineMath: [['\\(', '\\)']],
                displayMath: [['$$', '$$']],
            },
            svg: {
                fontCache: 'global'
            },
            startup: {
                pageReady: () => {
                    return MathJax.startup.defaultPageReady();
                }
            }
        };
    </script>
    <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"></script>

    <style>
        :root {
            /* Palette: Deep Space & Neon Glass */
            --bg-deep: #030508;
            --bg-gradient: linear-gradient(135deg, #0f172a 0%, #020617 100%);

            /* Glass Layers */
            --glass-surface: rgba(255, 255, 255, 0.03);
            --glass-border: rgba(255, 255, 255, 0.08);
            --glass-highlight: rgba(255, 255, 255, 0.15);
            --glass-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.36);

            /* Text */
            --text-primary: #f8fafc;
            --text-secondary: #94a3b8;
            --text-muted: #64748b;
            --text-glow: 0 0 20px rgba(255, 255, 255, 0.1);

            /* Accents with Glows */
            --accent-blue: #38bdf8;
            --glow-blue: 0 0 20px rgba(56, 189, 248, 0.4);

            --accent-purple: #c084fc;
            --glow-purple: 0 0 20px rgba(192, 132, 252, 0.4);

            --accent-amber: #fbbf24;
            --glow-amber: 0 0 20px rgba(251, 191, 36, 0.4);

            --accent-green: #34d399;
            --glow-green: 0 0 20px rgba(52, 211, 153, 0.4);

            --accent-red: #f87171;
            --accent-code: #f472b6;

            /* Compatibility / Layout Colors */
            --bg-surface: rgba(255, 255, 255, 0.05);
            --bg-elevated: rgba(255, 255, 255, 0.1);

            /* Typography */
            --font-display: 'Space Grotesk', system-ui, sans-serif;
            --font-body: 'Source Sans 3', system-ui, sans-serif;
            --font-mono: 'JetBrains Mono', monospace;

            /* Spacing */
            --slide-padding: 80px 100px;
        }

        /* --- Global Reset & Body --- */
        * {
            box-sizing: border-box;
        }

        body,
        html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            font-family: var(--font-body);
            color: var(--text-primary);
            background: var(--bg-deep);
        }

        /* Animated Mesh Background */
        body::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background:
                radial-gradient(circle at 50% 50%, rgba(56, 189, 248, 0.08) 0%, transparent 40%),
                radial-gradient(circle at 80% 20%, rgba(192, 132, 252, 0.08) 0%, transparent 30%);
            animation: drift 60s infinite linear;
            z-index: 0;
            pointer-events: none;
        }

        @keyframes drift {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }

        /* --- App Container --- */
        #app {
            width: 100vw;
            height: 100vh;
            position: relative;
            z-index: 1;
        }

        /* --- Slide Container --- */
        .slide-viewer {
            width: 100%;
            height: 100%;
            position: relative;
            perspective: 1000px;
        }

        .slide-container {
            width: 100%;
            height: 100%;
            position: absolute;
            top: 0;
            left: 0;
            display: flex;
            opacity: 0;
            transform: scale(0.98) translateY(10px);
            transition: opacity 0.6s cubic-bezier(0.16, 1, 0.3, 1), transform 0.6s cubic-bezier(0.16, 1, 0.3, 1);
            pointer-events: none;
            overflow: hidden;
        }

        .slide-container.active {
            opacity: 1;
            transform: scale(1) translateY(0);
            pointer-events: all;
        }

        .slide-content {
            width: 100%;
            height: 100%;
            padding: var(--slide-padding);
            position: relative;
            z-index: 10;
            display: flex;
            flex-direction: column;
        }

        /* --- Typography --- */
        h1,
        h2,
        h3 {
            font-family: var(--font-display);
            margin: 0 0 1.5rem 0;
            line-height: 1.1;
            letter-spacing: -0.02em;
        }

        h1 {
            font-size: 5.5rem;
            font-weight: 700;
            background: linear-gradient(135deg, white 0%, #cbd5e1 100%);
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
            filter: drop-shadow(0 0 30px rgba(255, 255, 255, 0.1));
        }

        h2 {
            font-size: 3.5rem;
            font-weight: 600;
            color: var(--accent-blue);
            text-shadow: var(--glow-blue);
        }

        h3 {
            font-size: 2rem;
            font-weight: 600;
            color: var(--text-primary);
        }

        p,
        li {
            font-size: 1.6rem;
            line-height: 1.7;
            color: var(--text-secondary);
            margin-bottom: 1.2rem;
            max-width: 65ch;
        }

        strong {
            color: var(--text-primary);
            font-weight: 700;
        }

        /* --- Code Blocks (Glass Terminal) --- */
        pre {
            background: rgba(0, 0, 0, 0.4) !important;
            backdrop-filter: blur(12px);
            border: 1px solid var(--glass-border);
            border-radius: 12px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.4);
            margin: 2rem 0;
            position: relative;
            overflow: hidden;
        }

        /* Terminal Header */
        pre::before {
            content: '● ● ●';
            position: absolute;
            top: 12px;
            left: 16px;
            font-size: 10px;
            color: var(--text-muted);
            letter-spacing: 4px;
        }

        pre code {
            font-family: var(--font-mono);
            padding: 3rem 1.5rem 1.5rem 1.5rem !important;
            font-size: 1.1rem;
            background: transparent !important;
        }

        code {
            font-family: var(--font-mono);
            color: var(--accent-purple);
            background: rgba(192, 132, 252, 0.1);
            padding: 0.2em 0.4em;
            border-radius: 6px;
            font-size: 0.9em;
            border: 1px solid rgba(192, 132, 252, 0.2);
        }

        /* --- Layouts --- */

        /* Title Slide */
        .layout-title-slide {
            justify-content: center;
            align-items: center;
            text-align: center;
            background: radial-gradient(circle at center, rgba(56, 189, 248, 0.05) 0%, transparent 60%);
        }

        .layout-title-slide h1 {
            font-size: 6.5rem;
            margin-bottom: 1rem;
        }

        .layout-title-slide h2 {
            font-size: 2.2rem;
            color: var(--text-secondary);
            text-shadow: none;
            -webkit-text-fill-color: var(--text-secondary);
            font-weight: 400;
            margin-bottom: 4rem;
        }

        .layout-title-slide .footer {
            position: absolute;
            bottom: 40px;
            font-family: var(--font-mono);
            font-size: 0.9rem;
            color: var(--text-muted);
            opacity: 0.6;
            letter-spacing: 2px;
            text-transform: uppercase;
        }

        /* Grid Layouts */
        .layout-split {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 5rem;
            height: 100%;
            align-items: center;
        }

        .col-visual {
            height: 100%;
            display: flex;
            flex-direction: column;
            background: var(--glass-surface);
            backdrop-filter: blur(10px);
            border: 1px solid var(--glass-border);
            border-radius: 20px;
            overflow: hidden;
            box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.5);
            position: relative;
            transition: transform 0.4s ease;
        }

        .simulation-container {
            flex: 1;
            min-height: 0;
            width: 100%;
        }

        .col-visual:hover {
            transform: translateY(-5px);
            border-color: var(--glass-highlight);
            box-shadow: 0 35px 60px -15px rgba(0, 0, 0, 0.6), 0 0 30px rgba(56, 189, 248, 0.1);
        }

        .col-visual img {
            width: 100%;
            height: 100%;
            object-fit: contain;
            /* Changed from cover to contain to see full diagrams */
            padding: 2rem;
        }

        /* Section Break */
        .layout-section-break {
            justify-content: center;
            align-items: center;
            text-align: center;
            background: linear-gradient(45deg, rgba(56, 189, 248, 0.1) 0%, rgba(0, 0, 0, 0) 100%);
        }

        /* Missing Layouts */
        .col-text {
            display: flex;
            flex-direction: column;
            justify-content: center;
            height: 100%;
        }

        .ratio-40-60 {
            grid-template-columns: 0.8fr 1.2fr;
        }

        .ratio-55-45 {
            grid-template-columns: 1.1fr 0.9fr;
        }

        .slide-bg-image {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-size: cover;
            background-position: center;
            opacity: 0.2;
            z-index: 0;
            pointer-events: none;
            mix-blend-mode: luminosity;
        }

        .layout-comparison {
            display: grid;
            grid-template-columns: 1fr 1px 1fr;
            gap: 2rem;
            height: 100%;
            width: 100%;
        }

        .col-compare {
            padding: 2rem;
            display: flex;
            flex-direction: column;
        }

        .divider {
            background: var(--glass-border);
            height: 80%;
            align-self: center;
            width: 1px;
        }

        .layout-section-break h1 {
            font-size: 5rem;
            color: var(--accent-blue);
            margin-bottom: 1rem;
            -webkit-text-fill-color: var(--accent-blue);
        }

        /* --- UI Elements --- */
        .progress-bg {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 6px;
            background: rgba(255, 255, 255, 0.05);
            z-index: 100;
        }

        .progress-bar {
            position: absolute;
            bottom: 0;
            left: 0;
            height: 6px;
            background: linear-gradient(90deg, var(--accent-blue), var(--accent-purple));
            box-shadow: 0 0 15px var(--accent-blue);
            transition: width 0.4s cubic-bezier(0.25, 1, 0.5, 1);
            z-index: 101;
        }

        .slide-counter {
            position: absolute;
            bottom: 30px;
            right: 40px;
            font-family: var(--font-mono);
            font-size: 1rem;
            color: var(--text-muted);
            background: rgba(0, 0, 0, 0.3);
            padding: 5px 10px;
            border-radius: 4px;
            border: 1px solid var(--glass-border);
            z-index: 100;
        }

        /* --- Utilities --- */
        .hidden {
            display: none !important;
        }

        /* Speaker Notes Panel (Modernized) */
        .notes-panel {
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 25vh;
            background: rgba(10, 10, 15, 0.95);
            backdrop-filter: blur(20px);
            border-top: 1px solid var(--accent-blue);
            padding: 3rem;
            transform: translateY(110%);
            transition: transform 0.4s cubic-bezier(0.16, 1, 0.3, 1);
            z-index: 200;
            box-shadow: 0 -20px 50px rgba(0, 0, 0, 0.5);
        }

        .notes-panel.visible {
            transform: translateY(0);
        }

        .notes-title {
            color: var(--accent-blue);
            font-family: var(--font-mono);
            font-size: 0.9rem;
            margin-bottom: 1rem;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        #notes-content {
            font-size: 1.4rem;
            color: #e2e8f0;
            line-height: 1.6;
            max-width: 1400px;
            margin: 0 auto;
        }

        /* Overview Grid */
        .overview-grid {
            background: rgba(3, 5, 8, 0.9);
            backdrop-filter: blur(20px);
        }

        .overview-thumb {
            aspect-ratio: 16/9;
            background: var(--bg-surface);
            border: 1px solid var(--glass-border);
            border-radius: 12px;
            transition: all 0.3s ease;
        }

        .overview-thumb:hover {
            border-color: var(--accent-blue);
            box-shadow: 0 0 20px rgba(56, 189, 248, 0.3);
            transform: scale(1.02);
        }

        .thumb-num {
            font-family: var(--font-mono);
            font-size: 0.8rem;
            color: var(--accent-blue);
            margin-bottom: 8px;
        }

        .thumb-title {
            font-size: 0.9rem;
            color: var(--text-primary);
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .overview-grid.active {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
            gap: 20px;
            padding: 40px;
            align-content: start;
            animation: fadeIn 0.3s ease;
        }

        /* --- Premium Button Styling --- */
        button,
        .btn {
            font-family: var(--font-mono);
            font-size: 0.95rem;
            font-weight: 600;
            letter-spacing: 0.5px;
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            position: relative;
            overflow: hidden;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            background: linear-gradient(135deg, rgba(56, 189, 248, 0.2), rgba(192, 132, 252, 0.2));
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            color: white;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        }

        button:hover,
        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(56, 189, 248, 0.3);
            border-color: var(--accent-blue);
            background: linear-gradient(135deg, rgba(56, 189, 248, 0.4), rgba(192, 132, 252, 0.3));
        }

        button:active,
        .btn:active {
            transform: translateY(0);
            box-shadow: 0 2px 10px rgba(56, 189, 248, 0.2);
        }

        button::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
            transition: left 0.5s ease;
        }

        button:hover::before {
            left: 100%;
        }

        /* --- Modal & Overlay Styling --- */
        .modal-overlay {
            display: none;
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.85);
            backdrop-filter: blur(10px);
            z-index: 500;
            justify-content: center;
            align-items: center;
        }

        .modal-overlay.active {
            display: flex;
            animation: fadeIn 0.2s ease;
        }

        .modal-content {
            background: linear-gradient(135deg, rgba(30, 41, 59, 0.95), rgba(15, 23, 42, 0.98));
            border: 1px solid var(--glass-border);
            border-radius: 16px;
            padding: 2rem;
            box-shadow: 0 25px 50px rgba(0, 0, 0, 0.5), 0 0 60px rgba(56, 189, 248, 0.1);
            min-width: 300px;
            text-align: center;
        }

        .modal-content h3 {
            margin: 0 0 1rem 0;
            color: var(--accent-blue);
        }

        .modal-input {
            width: 100%;
            padding: 15px;
            font-size: 2rem;
            font-family: var(--font-mono);
            text-align: center;
            background: var(--bg-surface);
            border: 2px solid var(--accent-blue);
            border-radius: 8px;
            color: white;
            outline: none;
            transition: all 0.3s ease;
        }

        .modal-input:focus {
            box-shadow: 0 0 20px rgba(56, 189, 248, 0.3);
            border-color: var(--accent-purple);
        }

        /* --- Full Simulation Layout --- */
        .layout-full-simulation {
            width: 100%;
            height: 100%;
            position: relative;
            display: flex;
            flex-direction: column;
        }

        .layout-full-simulation .overlay-title {
            position: absolute;
            top: 20px;
            left: 30px;
            z-index: 10;
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(10px);
            padding: 12px 25px;
            border-radius: 12px;
            border: 1px solid var(--glass-border);
        }

        .layout-full-simulation .overlay-title h2 {
            margin: 0;
            font-size: 1.6rem;
        }

        .layout-full-simulation .simulation-container {
            width: 100%;
            height: 100%;
            padding: 80px 20px 20px;
        }

        /* --- Enhanced Section Break --- */
        .layout-section-break {
            background:
                radial-gradient(ellipse at 30% 50%, rgba(56, 189, 248, 0.15) 0%, transparent 50%),
                radial-gradient(ellipse at 70% 50%, rgba(192, 132, 252, 0.15) 0%, transparent 50%),
                radial-gradient(circle at 50% 50%, rgba(251, 191, 36, 0.05) 0%, transparent 40%);
            animation: sectionPulse 6s ease-in-out infinite;
        }

        @keyframes sectionPulse {

            0%,
            100% {
                background-size: 100% 100%, 100% 100%, 100% 100%;
            }

            50% {
                background-size: 120% 120%, 120% 120%, 110% 110%;
            }
        }

        .layout-section-break h1 {
            font-size: 7rem !important;
            background: linear-gradient(135deg, var(--accent-blue) 0%, var(--accent-purple) 50%, var(--accent-amber) 100%);
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
            filter: drop-shadow(0 0 50px rgba(56, 189, 248, 0.5));
            animation: titleGlow 3s ease-in-out infinite;
        }

        @keyframes titleGlow {

            0%,
            100% {
                filter: drop-shadow(0 0 50px rgba(56, 189, 248, 0.5));
            }

            50% {
                filter: drop-shadow(0 0 70px rgba(192, 132, 252, 0.6));
            }
        }

        .layout-section-break h2 {
            font-size: 2rem;
            color: var(--text-primary) !important;
            -webkit-text-fill-color: var(--text-primary);
            text-shadow: none;
            margin-bottom: 1rem;
        }

        .layout-section-break p {
            max-width: 600px;
            text-align: center;
        }

        /* --- Animation Keyframes --- */
        @keyframes fadeIn {
            from {
                opacity: 0;
            }

            to {
                opacity: 1;
            }
        }

        @keyframes slideUp {
            from {
                opacity: 0;
                transform: translateY(40px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes scaleIn {
            from {
                opacity: 0;
                transform: scale(0.92);
            }

            to {
                opacity: 1;
                transform: scale(1);
            }
        }

        @keyframes float {

            0%,
            100% {
                transform: translateY(0);
            }

            50% {
                transform: translateY(-10px);
            }
        }

        /* --- Slide Content Animations --- */
        .slide-content h1 {
            animation: slideUp 0.7s cubic-bezier(0.16, 1, 0.3, 1) forwards;
        }

        .slide-content h2 {
            animation: slideUp 0.6s cubic-bezier(0.16, 1, 0.3, 1) 0.1s forwards;
            opacity: 0;
        }

        .slide-content .col-text {
            animation: slideUp 0.6s cubic-bezier(0.16, 1, 0.3, 1) 0.15s forwards;
            opacity: 0;
        }

        .slide-content .col-visual {
            animation: scaleIn 0.7s cubic-bezier(0.16, 1, 0.3, 1) 0.25s forwards;
            opacity: 0;
        }

        .slide-content ul,
        .slide-content p {
            animation: slideUp 0.5s cubic-bezier(0.16, 1, 0.3, 1) 0.2s forwards;
            opacity: 0;
        }

        /* --- Simulation Container Styling --- */
        .simulation-container {
            border-radius: 12px;
            overflow: hidden;
        }

        /* Code slide overflow fix */
        .col-visual pre {
            max-height: calc(100% - 2rem);
            overflow-y: auto;
        }
        .col-visual {
            overflow: hidden;
        }

        /* Notes panel drag handle */
        .notes-drag-handle {
            width: 60px;
            height: 5px;
            background: var(--text-muted);
            border-radius: 3px;
            margin: 0 auto 10px;
            cursor: ns-resize;
            opacity: 0.5;
            transition: opacity 0.2s;
        }
        .notes-drag-handle:hover {
            opacity: 1;
        }

        /* --- Enhanced List Items --- */
        .slide-content li {
            position: relative;
            padding-left: 1.5rem;
            margin-bottom: 0.8rem;
        }

        .slide-content li::before {
            content: '▸';
            position: absolute;
            left: 0;
            color: var(--accent-blue);
            font-weight: bold;
        }

        /* --- Input & Range Styling --- */
        input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
            width: 100%;
            height: 6px;
            background: var(--bg-elevated);
            border-radius: 3px;
            outline: none;
            margin: 10px 0;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 18px;
            height: 18px;
            background: var(--accent-blue);
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 0 10px rgba(56, 189, 248, 0.5);
            transition: all 0.2s ease;
        }

        input[type="range"]::-webkit-slider-thumb:hover {
            transform: scale(1.2);
            box-shadow: 0 0 15px rgba(56, 189, 248, 0.7);
        }

        input[type="text"],
        textarea {
            background: var(--bg-surface);
            border: 1px solid var(--glass-border);
            border-radius: 8px;
            color: white;
            font-family: var(--font-body);
            transition: all 0.3s ease;
        }

        input[type="text"]:focus,
        textarea:focus {
            border-color: var(--accent-blue);
            box-shadow: 0 0 15px rgba(56, 189, 248, 0.2);
            outline: none;
        }

        /* --- Title Slide Enhancements --- */
        .layout-title-slide {
            background:
                radial-gradient(circle at 50% 30%, rgba(56, 189, 248, 0.08) 0%, transparent 50%),
                radial-gradient(circle at 30% 70%, rgba(192, 132, 252, 0.06) 0%, transparent 40%),
                radial-gradient(circle at 70% 80%, rgba(251, 191, 36, 0.04) 0%, transparent 30%);
        }

        .layout-title-slide h1 {
            font-size: 5.5rem;
            margin-bottom: 1.5rem;
            animation: slideUp 0.8s cubic-bezier(0.16, 1, 0.3, 1) forwards;
        }

        .layout-title-slide h2 {
            animation: slideUp 0.6s cubic-bezier(0.16, 1, 0.3, 1) 0.2s forwards;
            opacity: 0;
        }

        .layout-title-slide .footer {
            animation: fadeIn 0.5s ease 0.5s forwards;
            opacity: 0;
        }
    </style>
</head>

<body>
    <div id="debug-overlay"
        style="position:fixed; top:0; left:0; width:100%; z-index:9999; background:rgba(0,0,0,0.8); color:red; padding:20px; font-family:monospace; display:none;">
        <h3>Debug Log</h3>
        <ul id="debug-errors"></ul>
        <button onclick="document.getElementById('debug-overlay').style.display='none'"
            style="margin-top:10px;">Close</button>
    </div>
    <script>
        window.onerror = function (message, source, lineno, colno, error) {
            const overlay = document.getElementById('debug-overlay');
            const list = document.getElementById('debug-errors');
            overlay.style.display = 'block';
            const li = document.createElement('li');
            li.innerText = `Error: ${message} at ${source}:${lineno}:${colno}`;
            list.appendChild(li);
            console.error(message, source, lineno, colno, error);
            // Don't swallow the error
            return false;
        };
        console.log("Debug overlay initialized");
    </script>

    <div id="app">
        <!-- Slides will be rendered here -->
        <div id="slide-viewer" class="slide-viewer">
            <div
                style="display:flex;justify-content:center;align-items:center;height:100%;font-size:2rem;color:var(--text-secondary);">
                Loading Presentation...<br>
                <span style="font-size:1rem;margin-top:1rem;">(If this persists, check console or debug log)</span>
            </div>
        </div>

        <!-- UI Overlays -->
        <div class="progress-bg" id="progress-bg"></div>
        <div class="progress-bar" id="progress-bar" style="width: 0%"></div>
        <div class="slide-counter" id="slide-counter">1 / 10</div>

        <!-- Speaker Notes -->
        <div class="notes-panel" id="notes-panel">
            <div class="notes-drag-handle" id="notes-drag-handle"></div>
            <div class="notes-title">Speaker Notes</div>
            <div id="notes-content"></div>
        </div>

        <!-- Go To Slide Modal -->
        <div class="modal-overlay" id="goto-modal">
            <div class="modal-content">
                <h3>Go to Slide</h3>
                <input type="number" id="goto-input" class="modal-input" placeholder="#" min="1">
            </div>
        </div>

        <!-- Overview Mode -->
        <div class="overview-grid" id="overview-grid"></div>
    </div>

    <script>
        // --- Data Definitions ---
        const SLIDES = [
            // --- ACT 1 ---
            {
                id: 1,
                layout: 'title-slide',
                title: "Building the Transformer from Scratch",
                subtitle: "From Ancient Statistics to Modern AI",
                footer: "Applied AI Meetup Hackathon",
                image: "images/slide_01_title.png",
                notes: "Welcome everyone. The modern AI you interact with daily — ChatGPT, Claude, all of these systems — didn't just pop out of nowhere. They're the culmination of centuries of humans trying to answer one fundamental question: Can we predict the future from patterns in the past?"
            },
            {
                id: 2,
                layout: 'content-image',
                title: "Humanity's Oldest Obsession: Counting Things",
                content: `
                    <ul>
                        <li><strong>Romans:</strong> Census every 5 years ("lustrum") — family, property, wealth</li>
                        <li><strong>China:</strong> Population registers from Xia Dynasty (~2000 BCE). Han Dynasty counted 57 million people in 2 CE</li>
                        <li><strong>India:</strong> Chanakya's Arthashastra (~300 BCE) — demographic records</li>
                        <li><strong>Purpose:</strong> Taxation, military conscription, food distribution</li>
                    </ul>
                    <p>All backward-looking — counting what existed, not predicting what would come.</p>
                `,
                image: "images/slide_02_ancient_data.png",
                notes: "For most of history, data was about record-keeping. The Romans, Chinese, and Indians built massive bureaucracies just to count what they had. This was 'descriptive statistics' before the term existed. It was backward-looking."
            },
            {
                id: 3,
                layout: 'content-image',
                title: "Fun Fact: The First Computer Was Built for the Census",
                content: `
                    <ul>
                        <li><strong>1880 US Census:</strong> took 8 years to process manually</li>
                        <li><strong>Herman Hollerith:</strong> Invented electromechanical tabulating machine (punch cards)</li>
                        <li><strong>1890 Census:</strong> Processed 62 million people in ~1 year</li>
                        <li><strong>Legacy:</strong> Hollerith's company → CTR → renamed 1924 → <strong>IBM</strong></li>
                    </ul>
                    <p>Modern computing has its roots in the humble census.</p>
                `,
                image: "images/slide_03_hollerith.png",
                notes: "In 1880, the US census took 8 years to count. They barely finished before the next one started. Herman Hollerith invented a machine using punch cards—inspired by train conductor tickets—to tabulate data. He founded a company that eventually became IBM. The lineage of AI stats helps."
            },
            {
                id: 4,
                layout: 'content-simulation',
                title: "Making Sense of Data: The Statistical Toolkit",
                content: `
                    <ul>
                        <li><strong>1662 John Graunt:</strong> First life tables from London death records</li>
                        <li><strong>1713 Jakob Bernoulli:</strong> Law of Large Numbers</li>
                        <li><strong>De Moivre / Gauss:</strong> Normal distribution (bell curve)</li>
                        <li><strong>Bayes:</strong> Updating beliefs with evidence</li>
                    </ul>
                    <p>The foundations of how we train neural nets (Least Squares) date back to Gauss.</p>
                `,
                simulation: 'sim-1',
                notes: "As we collected more data, we needed math to understand it. Bernoulli gave us the Law of Large Numbers—the idea that more data equals closer to truth. Gauss gave us the bell curve and least squares regression, which is still how we calculate loss in neural networks today."
            },
            {
                id: 5,
                layout: 'content-image',
                title: "Probability Theory: Born at the Gambling Table",
                content: `
                    <ul>
                        <li><strong>1654:</strong> Chevalier de Méré asks Pascal about dice odds</li>
                        <li><strong>Pascal ↔ Fermat:</strong> Correspondence lays foundations of probability</li>
                        <li><strong>Laplace:</strong> "Common sense reduced to calculation"</li>
                        <li><strong>Key Assumption:</strong> Independence (Dice have no memory)</li>
                    </ul>
                    <p>But what about language? Does the next word depend on the previous one?</p>
                `,
                image: "images/slide_05_pascal_dice.png",
                notes: "Probability didn't come from science, it came from gambling. Pascal and Fermat worked out the math of dice. But they assumed events were independent. A die doesn't remember the last roll. But language is different. 'Queen' is much more likely after 'King' than after 'Sandwich'."
            },
            {
                id: 6,
                layout: 'content-image',
                title: "1913: A Theological Argument Changes Mathematics",
                content: `
                    <ul>
                        <li><strong>Pavel Nekrasov (Theologian):</strong> Claimed Law of Large Numbers <em>requires</em> independence. Independence = Free Will.</li>
                        <li><strong>Andrey Markov (Mathematician):</strong> "Nonsense."</li>
                        <li><strong>Markov's Goal:</strong> Prove LLN holds even for dependent events.</li>
                    </ul>
                    <p>He didn't argue philosophically. He calculated.</p>
                `,
                image: "images/slide_06_markov_nekrasov.png",
                notes: "In 1913, a theologian named Nekrasov argued that because the Law of Large Numbers requires independence, humans must have free will (independence). Andrey Markov, a grumpy mathematician, hated this. He set out to prove that you can have dependent events that still follow statistical laws."
            },
            {
                id: 7,
                layout: 'content-simulation',
                title: "Markov Analyzes Eugene Onegin",
                content: `
                    <p>Markov analyzed 20,000 characters of Pushkin's <em>Eugene Onegin</em>.</p>
                    <p>He classified letters as Vowel (V) or Consonant (C).</p>
                    <ul>
                        <li><strong>Finding:</strong> Consonants are much more likely after Vowels.</li>
                        <li><strong>Conclusion:</strong> Events are <em>dependent</em>, yet proportions stabilize.</li>
                        <li>Nekrasov was wrong. Dependence exists. Patterns exist.</li>
                    </ul>
                `,
                simulation: 'sim-2',
                notes: "Markov manually counted 20,000 letters of 'Eugene Onegin'. He showed that after a vowel, a consonant is likely. After a consonant, a vowel is likely. They are dependent. But the overall statistics still work. This was the birth of the Markov Chain."
            },
            {
                id: 8,
                layout: 'full-simulation',
                title: "Markov Chains: Predicting the Next State",
                simulation: 'sim-3',
                notes: "This is a Markov Chain. It predicts the next state based ONLY on the current state. This is the great-grandfather of ChatGPT. It's next-token prediction, but with a context window of size 1."
            },

            // --- ACT 2 ---
            {
                id: 9,
                layout: 'section-break',
                title: "ACT II",
                subtitle: "From Markov Chains to Transformers",
                description: "Each solution unlocked new capabilities but revealed new limitations. Each limitation drove the next innovation."
            },
            {
                id: 9.5,
                layout: 'full-simulation',
                title: "The Artificial Neuron: Inspired by Biology",
                simulation: 'sim-neuron',
                notes: "Before we get to the Perceptron, let's understand the basic building block: the artificial neuron. It takes inputs, multiplies each by a weight, sums them up, adds a bias, and passes through an activation function. This is inspired by biological neurons that fire when their combined input exceeds a threshold."
            },
            {
                id: 10,
                layout: 'content-simulation',
                title: "1958: The Perceptron — Learning from Data",
                content: `
                    <ul>
                        <li><strong>1943:</strong> McCulloch & Pitts model a neuron</li>
                        <li><strong>1958:</strong> Frank Rosenblatt invents the Perceptron</li>
                        <li><strong>Mechanism:</strong> Weighted inputs → Sum → Threshold → Output</li>
                        <li><strong>Hype:</strong> NYT claimed it would "walk, talk, see, write, reproduces itself"</li>
                    </ul>
                `,
                simulation: 'sim-4',
                notes: "In 1958, Rosenblatt built the Perceptron. It was a hardware device with 400 photocells. It could learn to classify simple shapes. The hype was insane—the New York Times said it would eventually talk, see, and reproduce itself. They were right, it just took 65 years."
            },
            {
                id: 11,
                layout: 'content-simulation',
                title: "1969: The XOR Problem Kills Neural Networks",
                content: `
                    <p>Minsky & Papert proved a single-layer perceptron cannot solve <strong>XOR</strong>.</p>
                    <ul>
                        <li>Linear separation works for AND/OR, but not XOR.</li>
                        <li>We needed hidden layers, but didn't know how to train them.</li>
                        <li><strong>Result:</strong> First AI Winter. Funding vanished.</li>
                    </ul>
                `,
                simulation: 'sim-5',
                notes: "Then came Minsky and Papert. They proved mathematically that a single perceptron couldn't solve the XOR problem. It couldn't separate two classes that weren't linearly separable. This killed funding for neural nets for a decade. The first AI Winter."
            },
            {
                id: 12,
                layout: 'full-simulation',
                title: "1986: Backpropagation — The Breakthrough",
                simulation: 'sim-6',
                notes: "In 1986, Hinton, Rumelhart, and Williams popularized Backpropagation. It gave us a way to train deep networks. You calculate the error at the output, and propagate it backward to update the weights. The Chain Rule in action."
            },
            {
                id: 13,
                layout: 'content-simulation',
                title: "The Vanishing Gradient Problem",
                content: `
                    <p>Backprop enabled depth, but only up to a point.</p>
                    <ul>
                        <li>Gradients multiply through layers (Chain Rule).</li>
                        <li>If weights/activations are small (< 1), gradients shrink exponentially.</li>
                        <li><strong>Result:</strong> Early layers stop learning.</li>
                        <li><strong>Solutions:</strong> ReLU, Residual Connections, BatchNorm.</li>
                    </ul>
                `,
                simulation: 'sim-7',
                notes: "But deep networks were hard to train. As you go back many layers, the gradient signal gets multiplied by small numbers over and over. It vanishes. The early layers—which should learn basic features—never get the signal to change."
            },
            {
                id: 14,
                layout: 'content-simulation',
                title: "Recurrent Neural Networks: Memory at a Cost",
                content: `
                    <p><strong>Idea:</strong> Use a hidden state that loops back as memory.</p>
                    <ul>
                        <li>great for sequences (time series, language).</li>
                        <li><strong>Problem:</strong> Vanishing gradient <em>through time</em>.</li>
                        <li>Can only remember recent history. "The cat..." (100 words later) "...sat?"</li>
                    </ul>
                `,
                simulation: 'sim-8',
                notes: "For language, we used Recurrent Neural Networks (RNNs). They have a loop. They pass a hidden state from word to word. This implies memory. But the vanishing gradient strikes again—this time through time. An RNN forgets the beginning of the sentence by the time it reaches the end."
            },
            {
                id: 15,
                layout: 'content-image',
                title: "1997: LSTMs — Learning What to Remember",
                content: `
                     <p>Hochreiter & Schmidhuber (1997) proposed <strong>L</strong>ong <strong>S</strong>hort-<strong>T</strong>erm <strong>M</strong>emory.</p>
                     <ul>
                         <li><strong>Gating Mechanism:</strong> Forget Gate, Input Gate, Output Gate.</li>
                         <li>Allows gradients to flow unchanged through the "cell state".</li>
                         <li>Dominated NLP for 20 years (Translation, Speech).</li>
                         <li><strong>Limitation:</strong> Still sequential. Hard to parallelize.</li>
                     </ul>
                `,
                image: "images/slide_14_lstm_gates.png",
                notes: "LSTMs fixed the memory problem with gates—valves that control information flow. They could remember things for longer. They powered Google Translate for years. But they were still sequential. You had to process word 1 before word 2."
            },
            {
                id: 16,
                layout: 'full-simulation',
                title: "Representing Words: From One-Hot to Embeddings",
                simulation: 'sim-9',
                notes: "How do we even talk to computers? We used to use One-Hot encoding—big vectors of zeros. Now we use Embeddings. We represent words as vectors in a high-dimensional space. Words with similar meanings are close together."
            },
            {
                id: 17,
                layout: 'code-slide',
                title: "Word2Vec: You Shall Know a Word by the Company It Keeps",
                content: `
                    <p><strong>J.R. Firth (1957):</strong> Meaning comes from context.</p>
                    <ul>
                        <li><strong>Skip-gram:</strong> Predict context from word.</li>
                        <li><strong>CBOW:</strong> Predict word from context.</li>
                        <li>Vector Arithmetic: <code>King - Man + Woman = Queen</code></li>
                    </ul>
                `,
                code: `# Conceptual Word2Vec
# Training objective: predict context from target word

# "The cat sat on the mat"
# Skip-gram pairs (window=2):
#   (cat, The), (cat, sat), (cat, on)
#   (sat, cat), (sat, on), (sat, the)

# Result: embedding_matrix[vocab_size, 300]
# king - man + woman ≈ queen
embedding["king"] - embedding["man"] + embedding["woman"]
# → closest vector: embedding["queen"]`,
                notes: "Word2Vec showed us that we can learn these embeddings just by looking at which words appear near each other. King minus Man plus Woman equals Queen. Philosophy became geometry."
            },
            {
                id: 18,
                layout: 'content-simulation',
                title: "2014: Attention — Learning Where to Focus",
                content: `
                    <p><strong>Bottleneck:</strong> Encoder compressed entire sentence into ONE vector.</p>
                    <p><strong>Solution:</strong> Let Decoder look back at ALL source states.</p>
                    <ul>
                        <li>Dynamic weights: Focus on "cat" when generating "chat".</li>
                        <li>Dramatically improved translation.</li>
                        <li>Still attached to RNNs/LSTMs.</li>
                    </ul>
                `,
                simulation: 'sim-10',
                notes: "In 2014, the Attention mechanism was introduced for translation. Instead of forcing the model to remember the whole sentence in one vector, we let it 'look back' at the source sentence at every step. It could 'attend' to relevant words."
            },
            {
                id: 19,
                layout: 'content-image',
                title: "2017: \"Attention Is All You Need\"",
                content: `
                    <p>Vaswani et al. (Google Brain) asked: <strong>Do we need the RNN at all?</strong></p>
                    <ul>
                        <li><strong>Self-Attention:</strong> Every token looks at every other token at once.</li>
                        <li><strong>Parallelization:</strong> No sequential dependency!</li>
                        <li><strong>Scalability:</strong> Bigger models, more data, faster training.</li>
                    </ul>
                `,
                image: "images/slide_18_attention_paper.png",
                notes: "Then in 2017, the paper dropped. 'Attention Is All You Need'. They threw away the RNN. No more loops. Just Attention. This meant we could process the whole sentence at once. Parallelization. This allowed us to train on the whole internet."
            },

            // --- ACT 3 ---
            {
                id: 20,
                layout: 'section-break',
                title: "ACT III",
                subtitle: "Inside the Transformer",
                description: "Let's open the hood and trace data through every component."
            },
            {
                id: 21,
                layout: 'content-simulation',
                title: "Step 1: Tokenization — Text to Numbers",
                content: `
                    <p>Modern models use <strong>Subword Tokenization</strong> (BPE/WordPiece).</p>
                    <ul>
                        <li>Common words = 1 token (e.g., "apple")</li>
                        <li>Rare words = multiple tokens (e.g., "un", "friend", "li", "ness")</li>
                        <li>Vocabulary size: ~50,000 to 100,000 tokens.</li>
                    </ul>
                `,
                simulation: 'sim-11',
                notes: "Step 1: Tokenization. We don't feed text to the model. We feed numbers. We break words into chunks called tokens. Common words are one token; complex words are split up. 'Unbelievable' might become 'Un', 'believ', 'able'."
            },
            {
                id: 22,
                layout: 'full-simulation',
                title: "Word Embeddings: Learning Meaning in Vector Space",
                simulation: 'sim-embed-3d',
                notes: "Each word becomes a point in high-dimensional space. During training, semantically similar words cluster together. Watch the relationship lines connecting similar concepts."
            },
            {
                id: 23,
                layout: 'content-simulation',
                title: "Step 2: Embeddings — IDs to Vectors",
                content: `
                    <p>Look up the vector for each token ID.</p>
                    <ul>
                        <li>Matrix: <code>[vocab_size, d_model]</code></li>
                        <li>Example: 50,000 × 512</li>
                        <li>Learned during training.</li>
                    </ul>
                `,
                simulation: 'sim-12',
                notes: "Step 2: Embeddings. We look up the visual representation for each token ID. Now we have a list of vectors."
            },
            {
                id: 23.5,
                layout: 'content-simulation',
                title: "Step 3: Positional Encoding — Where Am I?",
                content: `
                    <p>Self-attention is <em>permutation invariant</em>. It doesn't know order.</p>
                    <p>We must inject position information.</p>
                    <ul>
                        <li><strong>Sinusoidal:</strong> Wave patterns of different frequencies.</li>
                        <li><strong>Learned:</strong> The model learns position vectors.</li>
                        <li>Added to the embedding: <code>Input = Embed + PosEnc</code></li>
                    </ul>
                `,
                simulation: 'sim-13',
                notes: "Step 3: Positional Encoding. Since the Transformer looks at everything at once, it doesn't know that 'cat' came before 'sat'. We have to add a signal—a positional encoding—to tell it the order."
            },
            {
                id: 24,
                layout: 'content-simulation',
                title: "Step 4: Query, Key, Value — Three Views",
                content: `
                    <p>Each token vector is projected into 3 new vectors:</p>
                    <ul>
                        <li><strong>Query (Q):</strong> What am I looking for?</li>
                        <li><strong>Key (K):</strong> What do I contain?</li>
                        <li><strong>Value (V):</strong> What info do I pass along?</li>
                    </ul>
                    <p><code>d_model</code> (512) → <code>d_head</code> (64)</p>
                `,
                simulation: 'sim-14',
                notes: "Step 4: Q, K, V. This is the magic. Each token turns into three vectors. The Query asks 'what am I looking for?'. The Key says 'here is what I describe'. The Value says 'here is my content'."
            },
            {
                id: 25,
                layout: 'full-simulation',
                title: "Step 5: Self-Attention — The Heart",
                simulation: 'sim-15',
                notes: "Step 5: Self-Attention. We align the Queries with the Keys. If they match, we pay attention. Then we take the weighted sum of the Values. This is how 'it' knows to refer to 'the robot' and not 'the street'."
            },
            {
                id: 26,
                layout: 'content-simulation',
                title: "Step 6: Multi-Head Attention",
                content: `
                    <p>We do this 8 (or more) times in parallel.</p>
                    <ul>
                        <li><strong>Head 1:</strong> Focuses on grammar (Subject-Verb)</li>
                        <li><strong>Head 2:</strong> Focuses on pronouns (Co-reference)</li>
                        <li><strong>Head 3:</strong> Focuses on nearby words</li>
                    </ul>
                    <p>Results are concatenated and projected back to <code>d_model</code>.</p>
                `,
                simulation: 'sim-16',
                notes: "Step 6: Multi-Head. We don't just do this once. We do it 8 times, 12 times, 96 times in parallel. Each 'head' learns a different kind of relationship. Grammar, rhyme, logic, translation."
            },
            {
                id: 27,
                layout: 'content-simulation',
                title: "Step 7: Feed-Forward Network",
                content: `
                    <p>Processed independently for each token.</p>
                    <ul>
                        <li>Expansion: 512 → 2048</li>
                        <li><strong>ReLU/GELU:</strong> Non-linearity (The "thinking" happens here)</li>
                        <li>Contraction: 2048 → 512</li>
                    </ul>
                    <p><em>Attention = Communication. FFN = Computation.</em></p>
                `,
                simulation: 'sim-17',
                notes: "Step 7: The Feed Forwad Network. After the tokens talk to each other (attention), they need to think individually. This is a simple 2-layer neural net applied to each token separately."
            },
            {
                id: 28,
                layout: 'content-simulation',
                title: "Step 8: Residuals & Normalization",
                content: `
                    <ul>
                        <li><strong>Add:</strong> <code>x + Sublayer(x)</code> (The gradient highway)</li>
                        <li><strong>Norm:</strong> Keeps activations stable (mean=0, std=1)</li>
                    </ul>
                    <p>Essential for training deep networks (GPT-4 has ~100+ layers).</p>
                `,
                simulation: 'sim-18',
                notes: "Step 8: Residual Connections. We add the input back to the output. This creates a highway for gradients to flow all the way back to the start. This allows us to stack hundreds of layers without the vanishing gradient problem."
            },
            {
                id: 29,
                layout: 'full-simulation',
                title: "One Complete Transformer Block",
                simulation: 'sim-19',
                notes: "That's one block. In reality, we stack N of these. BERT uses 12 or 24. GPT-3 uses 96."
            },
            {
                id: 30,
                layout: 'three-column',
                title: "Three Transformer Architectures",
                content_left: `
                    <h3>Encoder-Only (BERT)</h3>
                    <svg width="150" height="100" viewBox="0 0 150 100" style="margin:10px auto; display:block;">
                        <rect x="10" y="30" width="30" height="30" rx="4" fill="var(--accent-blue)" opacity="0.3" stroke="var(--accent-blue)"/>
                        <rect x="60" y="30" width="30" height="30" rx="4" fill="var(--accent-blue)" opacity="0.3" stroke="var(--accent-blue)"/>
                        <rect x="110" y="30" width="30" height="30" rx="4" fill="var(--accent-blue)" opacity="0.3" stroke="var(--accent-blue)"/>
                        <line x1="40" y1="40" x2="60" y2="40" stroke="var(--accent-blue)" stroke-width="2" marker-end="url(#arrowBlue30)"/>
                        <line x1="60" y1="50" x2="40" y2="50" stroke="var(--accent-blue)" stroke-width="2" marker-end="url(#arrowBlue30)"/>
                        <line x1="90" y1="40" x2="110" y2="40" stroke="var(--accent-blue)" stroke-width="2" marker-end="url(#arrowBlue30)"/>
                        <line x1="110" y1="50" x2="90" y2="50" stroke="var(--accent-blue)" stroke-width="2" marker-end="url(#arrowBlue30)"/>
                        <text x="75" y="85" text-anchor="middle" fill="var(--text-muted)" font-size="11">Bidirectional</text>
                        <defs><marker id="arrowBlue30" viewBox="0 -3 6 6" refX="6" refY="0" markerWidth="5" markerHeight="5" orient="auto"><path d="M0,-3L6,0L0,3" fill="var(--accent-blue)"/></marker></defs>
                    </svg>
                    <ul>
                        <li>Bidirectional</li>
                        <li>Sees all context</li>
                        <li><strong>Use:</strong> Understanding, Search, Classification</li>
                    </ul>
                `,
                content_center: `
                    <h3>Decoder-Only (GPT)</h3>
                    <svg width="150" height="100" viewBox="0 0 150 100" style="margin:10px auto; display:block;">
                        <rect x="10" y="30" width="30" height="30" rx="4" fill="var(--accent-purple)" opacity="0.3" stroke="var(--accent-purple)"/>
                        <rect x="60" y="30" width="30" height="30" rx="4" fill="var(--accent-purple)" opacity="0.3" stroke="var(--accent-purple)"/>
                        <rect x="110" y="30" width="30" height="30" rx="4" fill="var(--accent-purple)" opacity="0.3" stroke="var(--accent-purple)"/>
                        <line x1="40" y1="45" x2="60" y2="45" stroke="var(--accent-purple)" stroke-width="2" marker-end="url(#arrowPurple30)"/>
                        <line x1="90" y1="45" x2="110" y2="45" stroke="var(--accent-purple)" stroke-width="2" marker-end="url(#arrowPurple30)"/>
                        <polygon points="5,25 145,25 145,65 5,65" fill="none" stroke="var(--accent-purple)" stroke-width="1" stroke-dasharray="3,3" opacity="0.4"/>
                        <line x1="5" y1="25" x2="145" y2="65" stroke="var(--accent-purple)" stroke-width="1" stroke-dasharray="3,3" opacity="0.4"/>
                        <text x="75" y="85" text-anchor="middle" fill="var(--text-muted)" font-size="11">Left-to-Right + Mask</text>
                        <defs><marker id="arrowPurple30" viewBox="0 -3 6 6" refX="6" refY="0" markerWidth="5" markerHeight="5" orient="auto"><path d="M0,-3L6,0L0,3" fill="var(--accent-purple)"/></marker></defs>
                    </svg>
                    <ul>
                        <li>Unidirectional</li>
                        <li>Causal Masking</li>
                        <li><strong>Use:</strong> Generation, Chat, Coding</li>
                    </ul>
                `,
                content_right: `
                    <h3>Encoder-Decoder (T5)</h3>
                    <svg width="150" height="100" viewBox="0 0 150 100" style="margin:10px auto; display:block;">
                        <rect x="10" y="15" width="55" height="30" rx="4" fill="var(--accent-blue)" opacity="0.3" stroke="var(--accent-blue)"/>
                        <text x="37" y="34" text-anchor="middle" fill="var(--accent-blue)" font-size="10">Encoder</text>
                        <rect x="85" y="15" width="55" height="30" rx="4" fill="var(--accent-green)" opacity="0.3" stroke="var(--accent-green)"/>
                        <text x="112" y="34" text-anchor="middle" fill="var(--accent-green)" font-size="10">Decoder</text>
                        <path d="M37,45 C37,65 112,65 112,45" fill="none" stroke="var(--accent-amber)" stroke-width="2" marker-end="url(#arrowAmber30)"/>
                        <text x="75" y="75" text-anchor="middle" fill="var(--accent-amber)" font-size="10">Cross-Attention</text>
                        <text x="75" y="95" text-anchor="middle" fill="var(--text-muted)" font-size="11">Hybrid</text>
                        <defs><marker id="arrowAmber30" viewBox="0 -3 6 6" refX="6" refY="0" markerWidth="5" markerHeight="5" orient="auto"><path d="M0,-3L6,0L0,3" fill="var(--accent-amber)"/></marker></defs>
                    </svg>
                    <ul>
                        <li>Hybrid</li>
                        <li>Cross-Attention</li>
                        <li><strong>Use:</strong> Translation, Summarization</li>
                    </ul>
                `,
                image: "images/slide_30_architectures.png",
                notes: "There are three ways to arrange these blocks. Encoder-only (like BERT) looks at the whole sentence—great for understanding. Decoder-only (like GPT) looks only at the past—great for generation. Encoder-Decoder (like the original) does both—great for translation."
            },
            {
                id: 31,
                layout: 'content-simulation',
                title: "The Decoder's Secret: Causal Masking",
                content: `
                    <p>When training GPT, we can't let it "cheat" by seeing the future.</p>
                    <ul>
                        <li><strong>Mask:</strong> Set attention scores for future tokens to -∞.</li>
                        <li><strong>Softmax:</strong> Converts -∞ to 0.</li>
                        <li>Ensures token <code>t</code> only attends to <code>0...t-1</code>.</li>
                    </ul>
                `,
                simulation: 'sim-20',
                notes: "For GPT, we have a rule: No cheating. You can't look at the future tokens. We enforce this with a 'Causal Mask'—a diagonal blinder that hides the future."
            },
            {
                id: 32,
                layout: 'content-simulation',
                title: "Final Step: Predicting the Next Token",
                content: `
                    <p>Output vector (512-dim) → Linear Layer → Logits (50,000-dim).</p>
                    <p><strong>Softmax:</strong> Convert logits to probabilities.</p>
                    <p>We sample from this distribution to get the next word.</p>
                `,
                simulation: 'sim-21',
                notes: "Finally, we take the output vector and project it up to the size of the vocabulary. We get a probability for every word in the dictionary. 'Cat' is 40%, 'Dog' is 20%. We roll the dice and pick one."
            },
            {
                id: 33,
                layout: 'comparison',
                title: "BERT vs GPT",
                content_left: `
                    <h3 style="color:var(--accent-blue);">BERT — "The Detective"</h3>
                    <div style="background:var(--bg-elevated); padding:15px; border-radius:10px; margin:10px 0; font-family:var(--font-mono); font-size:1.1rem; text-align:center;">
                        The <span style="background:var(--accent-amber); color:black; padding:2px 8px; border-radius:4px; font-weight:bold;">[MASK]</span> sat on the mat
                        <div style="margin-top:8px; font-size:0.85rem; color:var(--text-muted);">
                            <span style="color:var(--accent-blue);">←</span> Bidirectional — sees full context <span style="color:var(--accent-blue);">→</span>
                        </div>
                    </div>
                    <svg width="180" height="70" viewBox="0 0 180 70" style="margin:5px auto; display:block;">
                        <rect x="5" y="5" width="170" height="60" rx="4" fill="none" stroke="var(--accent-blue)" opacity="0.3"/>
                        ${[0,1,2,3,4].map(r => [0,1,2,3,4].map(c => '<rect x="'+(10+c*33)+'" y="'+(10+r*11)+'" width="28" height="8" rx="2" fill="var(--accent-blue)" opacity="'+(0.2+Math.random()*0.5)+'"/>').join('')).join('')}
                        <text x="90" y="68" text-anchor="middle" fill="var(--text-muted)" font-size="8">Full attention (all cells active)</text>
                    </svg>
                    <ul>
                        <li>Fill-in-the-blank training (MLM)</li>
                        <li>Discriminative — understands language</li>
                        <li>Best for: Search, Classification, NER</li>
                    </ul>
                `,
                content_right: `
                    <h3 style="color:var(--accent-purple);">GPT — "The Storyteller"</h3>
                    <div style="background:var(--bg-elevated); padding:15px; border-radius:10px; margin:10px 0; font-family:var(--font-mono); font-size:1.1rem; text-align:center;">
                        The cat sat <span style="color:var(--accent-amber); font-weight:bold;">...</span>
                        <div style="margin-top:8px; font-size:0.85rem; color:var(--text-muted);">
                            Autoregressive — predicts next token <span style="color:var(--accent-purple);">→</span>
                        </div>
                    </div>
                    <svg width="180" height="70" viewBox="0 0 180 70" style="margin:5px auto; display:block;">
                        <rect x="5" y="5" width="170" height="60" rx="4" fill="none" stroke="var(--accent-purple)" opacity="0.3"/>
                        ${[0,1,2,3,4].map(r => [0,1,2,3,4].map(c => c<=r ? '<rect x="'+(10+c*33)+'" y="'+(10+r*11)+'" width="28" height="8" rx="2" fill="var(--accent-purple)" opacity="'+(0.2+Math.random()*0.5)+'"/>' : '<rect x="'+(10+c*33)+'" y="'+(10+r*11)+'" width="28" height="8" rx="2" fill="#1e293b" opacity="0.3"/>').join('')).join('')}
                        <text x="90" y="68" text-anchor="middle" fill="var(--text-muted)" font-size="8">Causal mask (lower triangle only)</text>
                    </svg>
                    <ul>
                        <li>Next-token prediction training</li>
                        <li>Generative — creates language</li>
                        <li>Best for: Chat, Code, Creative Writing</li>
                    </ul>
                `,
                image: "images/slide_33_bert_vs_gpt.png",
                notes: "BERT is the detective; it sees the crime scene and deduces correctly. GPT is the storyteller; it invents the future one word at a time."
            },
            {
                id: 34,
                layout: 'code-slide',
                title: "How Transformers Learn: The Training Loop",
                content: `
                    <ul>
                        <li><strong>Pre-training:</strong> Massive corpus, self-supervised. "Learn language."</li>
                        <li><strong>Fine-tuning:</strong> Specific dataset. "Learn the task."</li>
                        <li><strong>RLHF:</strong> Learn values/preference.</li>
                    </ul>
                `,
                code: `# Simplified training loop
for batch in dataloader:
    # Forward pass
    input_tokens = batch["input_ids"]      # [batch_size, seq_len]
    predictions = model(input_tokens)       # [batch_size, seq_len, vocab_size]
    
    # Compute loss (next-token prediction)
    targets = batch["target_ids"]           # [batch_size, seq_len]
    loss = cross_entropy(predictions, targets)
    
    # Backward pass
    loss.backward()                         # Compute gradients
    clip_grad_norm_(model.parameters(), 1.0) # Prevent explosion
    optimizer.step()                        # Update weights
    optimizer.zero_grad()                   # Reset gradients
    
    # Learning rate schedule
    scheduler.step()`,
                notes: "The training loop is actually quite standard. Feed text, predict next token, calculate error, update weights. Repeat for 300 billion tokens."
            },
            {
                id: 35,
                layout: 'full-simulation',
                title: "The Complete Forward Pass",
                simulation: 'sim-22',
                notes: "Let's put it all together. Text to tokens. Tokens to embeddings. Add position. Attention. Feed Forward. Add. Norm. Repeat 96 times. Probability. Output. This is the miracle of modern AI."
            },
            {
                id: 36,
                layout: 'content-image',
                title: "Why Transformers Changed Everything",
                content: `
                    <div style="display:grid; grid-template-columns:1fr 1fr; gap:1rem;">
                        <div style="background:var(--bg-elevated); padding:1rem; border-radius:8px;">
                            <strong>1. Parallelization</strong><br>O(1) sequential steps per layer — fully parallel within a sequence, unlike RNNs which require O(n) sequential steps.
                        </div>
                        <div style="background:var(--bg-elevated); padding:1rem; border-radius:8px;">
                            <strong>2. Long-Range Dependency</strong><br>Direct access to any history.
                        </div>
                        <div style="background:var(--bg-elevated); padding:1rem; border-radius:8px;">
                            <strong>3. Scaling Laws</strong><br>Performance scales predictably with compute/data.
                        </div>
                        <div style="background:var(--bg-elevated); padding:1rem; border-radius:8px;">
                            <strong>4. Universality</strong><br>Works for text, image, audio, protein folding.
                        </div>
                    </div>
                `,
                image: "images/slide_30_architectures.png", // Reusing image as placeholder or we can use another
                notes: "Why did this architecture win? 1. It's parallelizable (fast). 2. It has infinite memory (attention). 3. It scales (just add more layers). 4. It's universal (everything is a sequence)."
            },
            {
                id: 37,
                layout: 'full-simulation',
                title: "From Markov to Transformers: The Full Arc",
                simulation: 'sim-23',
                notes: "We've come a long way. From counting Roman citizens to Markov chains to Perceptrons to Transformers. It's a single story of humanity's quest to predict the future."
            },
            {
                id: 38,
                layout: 'title-slide',
                title: "Now Let's Build One.",
                subtitle: "Transformer from scratch. 45 minutes. May the best model win.",
                footer: "github.com/AbhishekAdile/transformer-hackathon",
                image: "images/slide_34_hackathon_cta.png",
                notes: "Now it's your turn. Open your notebooks. Let's code."
            }
        ];

        // --- Simulations ---
        const SIMULATIONS = {
            'sim-1': (container) => { // Bell Curve - Enhanced
                container.innerHTML = `
                    <div style="height:100%; display:flex; flex-direction:column; padding:15px; box-sizing:border-box;">
                        <div id="sim1-chart" style="flex:1; min-height:0;"></div>
                        <div style="padding:15px 0; text-align:center; flex-shrink:0;">
                            <button id="sim1-btn">Add 50 Samples</button>
                            <button id="sim1-reset" style="margin-left:10px;">Reset</button>
                            <div style="margin-top:12px; font-family:var(--font-mono); display:flex; gap:2rem; justify-content:center;">
                                <span>Count: <span id="sim1-count" style="color:var(--accent-blue);font-weight:bold;">0</span></span>
                                <span>Mean: <span id="sim1-mean" style="color:var(--accent-amber);font-weight:bold;">0.00</span></span>
                                <span>StdDev: <span id="sim1-std" style="color:var(--accent-purple);font-weight:bold;">0.00</span></span>
                            </div>
                        </div>
                    </div>
                `;

                const chartContainer = document.getElementById('sim1-chart');
                const margin = { top: 30, right: 30, bottom: 40, left: 50 };
                const width = chartContainer.clientWidth - margin.left - margin.right;
                const height = chartContainer.clientHeight - margin.top - margin.bottom;

                const svg = d3.select("#sim1-chart").append("svg")
                    .attr("width", chartContainer.clientWidth)
                    .attr("height", chartContainer.clientHeight)
                    .append("g")
                    .attr("transform", `translate(${margin.left},${margin.top})`);

                // Add gradient definition for bars
                const defs = svg.append("defs");
                const gradient = defs.append("linearGradient")
                    .attr("id", "barGradient")
                    .attr("x1", "0%").attr("y1", "100%")
                    .attr("x2", "0%").attr("y2", "0%");
                gradient.append("stop").attr("offset", "0%").attr("stop-color", "rgba(251,191,36,0.3)");
                gradient.append("stop").attr("offset", "100%").attr("stop-color", "rgba(251,191,36,0.9)");

                // Add glow filter
                const filter = defs.append("filter").attr("id", "glow");
                filter.append("feGaussianBlur").attr("stdDeviation", "3").attr("result", "coloredBlur");
                const feMerge = filter.append("feMerge");
                feMerge.append("feMergeNode").attr("in", "coloredBlur");
                feMerge.append("feMergeNode").attr("in", "SourceGraphic");

                const x = d3.scaleLinear().domain([-4, 4]).range([0, width]);
                const y = d3.scaleLinear().domain([0, 0.5]).range([height, 0]);

                // Styled axes
                svg.append("g")
                    .attr("transform", `translate(0,${height})`)
                    .call(d3.axisBottom(x).ticks(10))
                    .attr("color", "#64748b")
                    .selectAll("line").attr("stroke", "#334155");

                svg.append("g")
                    .call(d3.axisLeft(y).ticks(5))
                    .attr("color", "#64748b")
                    .selectAll("line").attr("stroke", "#334155");

                // Theoretical curve with glow
                const pdf = z => (1 / Math.sqrt(2 * Math.PI)) * Math.exp(-0.5 * z * z);
                const line = d3.line().x(d => x(d[0])).y(d => y(d[1])).curve(d3.curveCatmullRom);
                const range = d3.range(-4, 4.05, 0.05).map(z => [z, pdf(z)]);

                // Curve shadow/glow
                svg.append("path")
                    .datum(range)
                    .attr("fill", "none")
                    .attr("stroke", "rgba(56,189,248,0.3)")
                    .attr("stroke-width", 8)
                    .attr("d", line)
                    .attr("filter", "url(#glow)");

                // Main theoretical curve
                svg.append("path")
                    .datum(range)
                    .attr("fill", "none")
                    .attr("stroke", "var(--accent-blue)")
                    .attr("stroke-width", 3)
                    .attr("d", line);

                // Label
                svg.append("text")
                    .attr("x", width / 2)
                    .attr("y", -10)
                    .attr("text-anchor", "middle")
                    .attr("fill", "var(--text-secondary)")
                    .attr("font-size", "12px")
                    .text("Standard Normal Distribution N(0,1)");

                let samples = [];

                function update(animate = true) {
                    const bins = d3.bin().domain(x.domain()).thresholds(x.ticks(30))(samples);

                    // Calculate bin width for proper density normalization
                    const binWidth = bins.length > 0 && bins[0].x1 !== undefined ?
                        (bins[0].x1 - bins[0].x0) : 0.25;

                    // Convert counts to probability density: density = count / (n * binWidth)
                    // This makes the histogram comparable to the PDF where area under curve = 1
                    bins.forEach(bin => {
                        bin.density = samples.length > 0 ? bin.length / (samples.length * binWidth) : 0;
                    });

                    const bars = svg.selectAll(".bar").data(bins);

                    // Enter + Update with proper density scale (same y scale as PDF)
                    bars.enter()
                        .append("rect")
                        .attr("class", "bar")
                        .attr("x", d => x(d.x0) + 1)
                        .attr("width", d => Math.max(0, x(d.x1) - x(d.x0) - 2))
                        .attr("y", height)
                        .attr("height", 0)
                        .attr("rx", 2)
                        .style("fill", "url(#barGradient)")
                        .merge(bars)
                        .transition()
                        .duration(animate ? 400 : 0)
                        .ease(d3.easeCubicOut)
                        .attr("y", d => y(d.density))
                        .attr("height", d => height - y(d.density));

                    bars.exit()
                        .transition()
                        .duration(200)
                        .attr("height", 0)
                        .attr("y", height)
                        .remove();

                    // Update stats
                    document.getElementById('sim1-count').innerText = samples.length;
                    if (samples.length > 0) {
                        document.getElementById('sim1-mean').innerText = d3.mean(samples).toFixed(3);
                        document.getElementById('sim1-std').innerText = d3.deviation(samples).toFixed(3);
                    } else {
                        document.getElementById('sim1-mean').innerText = "0.00";
                        document.getElementById('sim1-std').innerText = "0.00";
                    }
                }

                // Particle animation - reduced count and simplified for performance
                function addParticles(newSamples) {
                    // Only animate every 5th particle to reduce lag (10 particles instead of 50)
                    const step = 5;
                    for (let i = 0; i < newSamples.length; i += step) {
                        const val = newSamples[i];
                        const delay = (i / step) * 30; // Stagger particles slightly

                        const particle = svg.append("circle")
                            .attr("cx", x(val))
                            .attr("cy", -10)
                            .attr("r", 5)
                            .style("fill", "var(--accent-amber)")
                            .style("opacity", 0.85);

                        particle.transition()
                            .delay(delay)
                            .duration(600)
                            .ease(d3.easeBounceOut)
                            .attr("cy", height - 10)
                            .transition()
                            .duration(150)
                            .style("opacity", 0)
                            .on("end", function () { d3.select(this).remove(); });
                    }
                }

                document.getElementById('sim1-btn').onclick = () => {
                    const newSamples = [];
                    for (let i = 0; i < 50; i++) {
                        const sample = d3.randomNormal(0, 1)();
                        samples.push(sample);
                        newSamples.push(sample);
                    }
                    addParticles(newSamples);
                    setTimeout(() => update(true), 200);
                };

                document.getElementById('sim1-reset').onclick = () => {
                    samples = [];
                    svg.selectAll(".bar")
                        .transition()
                        .duration(300)
                        .attr("height", 0)
                        .attr("y", height)
                        .remove();
                    update(false);
                };
            },

            'sim-2': (container) => { // Markov Analysis - Enhanced
                container.innerHTML = `
                    <div style="height:100%; display:flex; flex-direction:column; padding:40px; box-sizing:border-box; gap:20px;">
                        <div style="display:flex; gap:30px; flex:1; min-height:0;">
                            <div style="flex:1; display:flex; flex-direction:column; justify-content:center;">
                                <h3 style="margin-bottom:10px;">Text Input</h3>
                                <textarea id="sim2-input" style="flex:1; max-height:150px; background:var(--bg-surface); color:white; border:1px solid var(--glass-border); padding:15px; font-family:var(--font-mono); font-size:1rem; resize:none; border-radius:8px;">My uncle has most honest principles: when taken ill in earnest he has made one respect him and invented nothing better. His example is a lesson; but, God, how deadly dull to tend a sick man day and night not daring to go far away! And how deceitful that fondness sickly to amuse one who is half alive, fluffing his pillows up, sadly bringing his medicine to him</textarea>
                                <div style="display:flex; gap:10px; margin-top:10px;">
                                    <button id="sim2-btn">Analyze</button>
                                    <button id="sim2-gen">Generate Sequence</button>
                                </div>
                            </div>
                            <div style="flex:1; display:flex; flex-direction:column; justify-content:center; align-items:center;">
                                <h3 style="margin-bottom:10px;">Transition Heatmap</h3>
                                <div id="sim2-matrix" style="width:100%; max-width:250px;"></div>
                            </div>
                        </div>
                        <div style="text-align:center;">
                            <div style="margin-bottom:5px; color:var(--text-muted); font-size:0.9rem;">Character Ribbon (V=amber, C=blue, other=gray)</div>
                            <div id="sim2-ribbon" style="display:flex; flex-wrap:wrap; justify-content:center; gap:1px; max-height:40px; overflow:hidden;"></div>
                        </div>
                        <div id="sim2-generated" style="text-align:center; min-height:40px;">
                            <div style="color:var(--text-muted); font-size:0.9rem; margin-bottom:5px;">Generated V/C Sequence</div>
                            <div id="sim2-gen-ribbon" style="display:flex; flex-wrap:wrap; justify-content:center; gap:1px;"></div>
                        </div>
                    </div>
                `;

                const vowels = "aeiou";
                let matrix = { vv: 0, vc: 0, cv: 0, cc: 0 };
                let totals = { v: 0, c: 0 };

                function makeRibbon(text, containerId, maxLen) {
                    const el = document.getElementById(containerId);
                    el.innerHTML = '';
                    const chars = text.slice(0, maxLen || 100);
                    chars.split('').forEach(ch => {
                        const span = document.createElement('span');
                        span.textContent = ch;
                        span.style.fontFamily = 'var(--font-mono)';
                        span.style.fontSize = '0.85rem';
                        span.style.padding = '1px 2px';
                        span.style.borderRadius = '2px';
                        const lower = ch.toLowerCase();
                        if (vowels.includes(lower)) {
                            span.style.color = 'var(--accent-amber)';
                            span.style.background = 'rgba(251,191,36,0.15)';
                        } else if (/[a-z]/i.test(ch)) {
                            span.style.color = 'var(--accent-blue)';
                            span.style.background = 'rgba(56,189,248,0.15)';
                        } else {
                            span.style.color = 'var(--text-muted)';
                            span.style.background = 'rgba(100,116,139,0.1)';
                        }
                        el.appendChild(span);
                    });
                }

                function renderMatrix() {
                    const el = document.getElementById('sim2-matrix');
                    const pVV = totals.v > 0 ? matrix.vv / totals.v : 0;
                    const pVC = totals.v > 0 ? matrix.vc / totals.v : 0;
                    const pCV = totals.c > 0 ? matrix.cv / totals.c : 0;
                    const pCC = totals.c > 0 ? matrix.cc / totals.c : 0;
                    const color = d3.scaleSequential(d3.interpolateYlOrRd).domain([0, 1]);
                    const cells = [
                        { r: 'V', c: 'V', v: pVV }, { r: 'V', c: 'C', v: pVC },
                        { r: 'C', c: 'V', v: pCV }, { r: 'C', c: 'C', v: pCC }
                    ];
                    el.innerHTML = `
                        <div style="display:grid; grid-template-columns:60px 1fr 1fr; gap:4px;">
                            <div></div><div style="text-align:center; font-weight:bold; color:var(--text-secondary);">→ V</div><div style="text-align:center; font-weight:bold; color:var(--text-secondary);">→ C</div>
                            <div style="font-weight:bold; color:var(--text-secondary); display:flex; align-items:center;">V →</div>
                            <div style="background:${color(pVV)}; padding:18px; text-align:center; border-radius:6px; font-weight:bold; color:${pVV > 0.5 ? 'black' : 'white'}; transition:background 0.5s;">${pVV.toFixed(2)}</div>
                            <div style="background:${color(pVC)}; padding:18px; text-align:center; border-radius:6px; font-weight:bold; color:${pVC > 0.5 ? 'black' : 'white'}; transition:background 0.5s;">${pVC.toFixed(2)}</div>
                            <div style="font-weight:bold; color:var(--text-secondary); display:flex; align-items:center;">C →</div>
                            <div style="background:${color(pCV)}; padding:18px; text-align:center; border-radius:6px; font-weight:bold; color:${pCV > 0.5 ? 'black' : 'white'}; transition:background 0.5s;">${pCV.toFixed(2)}</div>
                            <div style="background:${color(pCC)}; padding:18px; text-align:center; border-radius:6px; font-weight:bold; color:${pCC > 0.5 ? 'black' : 'white'}; transition:background 0.5s;">${pCC.toFixed(2)}</div>
                        </div>
                    `;
                }

                function analyze() {
                    const text = document.getElementById('sim2-input').value.toLowerCase().replace(/[^a-z]/g, '');
                    matrix = { vv: 0, vc: 0, cv: 0, cc: 0 };
                    totals = { v: 0, c: 0 };
                    for (let i = 0; i < text.length - 1; i++) {
                        const curr = vowels.includes(text[i]) ? 'v' : 'c';
                        const next = vowels.includes(text[i + 1]) ? 'v' : 'c';
                        matrix[curr + next]++;
                        totals[curr]++;
                    }
                    renderMatrix();
                    makeRibbon(document.getElementById('sim2-input').value, 'sim2-ribbon', 100);
                }

                function generate() {
                    if (totals.v === 0 && totals.c === 0) return;
                    const pVC = totals.v > 0 ? matrix.vc / totals.v : 0.5;
                    const pCV = totals.c > 0 ? matrix.cv / totals.c : 0.5;
                    let result = '';
                    let curr = Math.random() < 0.5 ? 'V' : 'C';
                    for (let i = 0; i < 50; i++) {
                        result += curr;
                        if (curr === 'V') curr = Math.random() < pVC ? 'C' : 'V';
                        else curr = Math.random() < pCV ? 'V' : 'C';
                    }
                    const ribbon = document.getElementById('sim2-gen-ribbon');
                    ribbon.innerHTML = '';
                    result.split('').forEach(ch => {
                        const span = document.createElement('span');
                        span.textContent = ch;
                        span.style.fontFamily = 'var(--font-mono)';
                        span.style.fontSize = '0.85rem';
                        span.style.padding = '2px 4px';
                        span.style.borderRadius = '3px';
                        span.style.color = ch === 'V' ? 'var(--accent-amber)' : 'var(--accent-blue)';
                        span.style.background = ch === 'V' ? 'rgba(251,191,36,0.2)' : 'rgba(56,189,248,0.2)';
                        ribbon.appendChild(span);
                    });
                }

                document.getElementById('sim2-btn').onclick = analyze;
                document.getElementById('sim2-gen').onclick = generate;
                analyze();
            },

            'sim-3': (container) => { // Markov Chain - Enhanced
                container.innerHTML = `
                    <div style="height:100%; display:flex; flex-direction:column; padding:20px;">
                        <div id="sim3-viz" style="flex:1; position:relative;"></div>
                        <div style="padding:15px; background:var(--glass-surface); border-radius:12px; margin-top:10px; border:1px solid var(--glass-border);">
                            <div style="display:flex; gap:15px; align-items:center;">
                                <span style="color:var(--text-secondary);">Generated:</span>
                                <span id="sim3-output" style="font-family:var(--font-mono); font-size:1.2rem; color:var(--accent-amber); flex:1;"></span>
                                <button id="sim3-clear">Clear</button>
                            </div>
                            <div style="margin-top:10px; color:var(--text-muted); font-size:0.85rem;">
                                Click nodes to build a sentence. Orange nodes show valid next words.
                            </div>
                        </div>
                    </div>
                `;

                const nodes = [
                    { id: "The" }, { id: "cat" }, { id: "dog" },
                    { id: "sat" }, { id: "ate" }, { id: "on" },
                    { id: "mat" }, { id: "apple" }
                ];
                const links = [
                    { source: "The", target: "cat", prob: 0.5 }, { source: "The", target: "dog", prob: 0.5 },
                    { source: "cat", target: "sat", prob: 0.6 }, { source: "cat", target: "ate", prob: 0.4 },
                    { source: "dog", target: "sat", prob: 0.7 }, { source: "dog", target: "ate", prob: 0.3 },
                    { source: "sat", target: "on", prob: 1.0 }, { source: "ate", target: "apple", prob: 1.0 },
                    { source: "on", target: "The", prob: 0.3 }, { source: "on", target: "mat", prob: 0.7 }
                ];

                const vizContainer = document.getElementById('sim3-viz');
                const width = vizContainer.clientWidth;
                const height = vizContainer.clientHeight;

                const svg = d3.select("#sim3-viz").append("svg")
                    .attr("width", width).attr("height", height);

                // Add defs for gradients and glows
                const defs = svg.append("defs");

                // Glow filter
                const glowFilter = defs.append("filter").attr("id", "nodeGlow");
                glowFilter.append("feGaussianBlur").attr("stdDeviation", "4").attr("result", "coloredBlur");
                const feMerge = glowFilter.append("feMerge");
                feMerge.append("feMergeNode").attr("in", "coloredBlur");
                feMerge.append("feMergeNode").attr("in", "SourceGraphic");

                // Arrow marker with gradient
                const marker = defs.append("marker")
                    .attr("id", "arrowGrad")
                    .attr("viewBox", "0 -5 10 10")
                    .attr("refX", 28).attr("refY", 0)
                    .attr("markerWidth", 6).attr("markerHeight", 6)
                    .attr("orient", "auto");
                marker.append("path").attr("fill", "var(--accent-blue)").attr("d", "M0,-5L10,0L0,5");

                // Active marker (orange)
                const markerActive = defs.append("marker")
                    .attr("id", "arrowActive")
                    .attr("viewBox", "0 -5 10 10")
                    .attr("refX", 28).attr("refY", 0)
                    .attr("markerWidth", 6).attr("markerHeight", 6)
                    .attr("orient", "auto");
                markerActive.append("path").attr("fill", "var(--accent-amber)").attr("d", "M0,-5L10,0L0,5");

                const simulation = d3.forceSimulation(nodes)
                    .force("link", d3.forceLink(links).id(d => d.id).distance(120))
                    .force("charge", d3.forceManyBody().strength(-500))
                    .force("center", d3.forceCenter(width / 2, height / 2))
                    .force("collision", d3.forceCollide().radius(40));

                // Links
                const link = svg.append("g").selectAll("line")
                    .data(links).enter().append("line")
                    .attr("stroke", "rgba(56, 189, 248, 0.4)")
                    .attr("stroke-width", d => 1 + d.prob * 2)
                    .attr("marker-end", "url(#arrowGrad)")
                    .style("transition", "all 0.3s ease");

                // Link labels (probability)
                const linkLabels = svg.append("g").selectAll("text")
                    .data(links).enter().append("text")
                    .attr("text-anchor", "middle")
                    .attr("fill", "var(--text-muted)")
                    .attr("font-size", "10px")
                    .attr("font-family", "var(--font-mono)")
                    .text(d => d.prob.toFixed(1));

                // Nodes group
                const node = svg.append("g").selectAll("g")
                    .data(nodes).enter().append("g")
                    .style("cursor", "pointer")
                    .call(d3.drag()
                        .on("start", (event, d) => {
                            if (!event.active) simulation.alphaTarget(0.3).restart();
                            d.fx = d.x; d.fy = d.y;
                        })
                        .on("drag", (event, d) => { d.fx = event.x; d.fy = event.y; })
                        .on("end", (event, d) => {
                            if (!event.active) simulation.alphaTarget(0);
                            d.fx = null; d.fy = null;
                        }));

                // Node glow circle (behind)
                node.append("circle")
                    .attr("class", "node-glow")
                    .attr("r", 28)
                    .attr("fill", "none")
                    .attr("stroke", "rgba(56, 189, 248, 0.3)")
                    .attr("stroke-width", 4)
                    .attr("filter", "url(#nodeGlow)");

                // Main node circle
                node.append("circle")
                    .attr("class", "node-main")
                    .attr("r", 24)
                    .attr("fill", "var(--bg-elevated)")
                    .attr("stroke", "var(--accent-blue)")
                    .attr("stroke-width", 2)
                    .style("transition", "all 0.3s ease");

                // Node labels
                node.append("text")
                    .attr("dy", 5)
                    .attr("text-anchor", "middle")
                    .text(d => d.id)
                    .attr("fill", "white")
                    .attr("font-weight", "600")
                    .attr("font-size", "12px")
                    .style("pointer-events", "none");

                simulation.on("tick", () => {
                    link.attr("x1", d => d.source.x).attr("y1", d => d.source.y)
                        .attr("x2", d => d.target.x).attr("y2", d => d.target.y);
                    linkLabels.attr("x", d => (d.source.x + d.target.x) / 2)
                        .attr("y", d => (d.source.y + d.target.y) / 2 - 5);
                    node.attr("transform", d => `translate(${d.x},${d.y})`);
                });

                // Interaction state
                let currentWord = "";
                let currentNodeId = null;

                function updateHighlights() {
                    const possible = currentNodeId
                        ? links.filter(l => l.source.id === currentNodeId).map(l => l.target.id)
                        : nodes.map(n => n.id);

                    // Update nodes
                    node.selectAll(".node-main")
                        .attr("stroke", d => d.id === currentNodeId ? "var(--accent-purple)" :
                            possible.includes(d.id) ? "var(--accent-amber)" : "var(--accent-blue)")
                        .attr("stroke-width", d => possible.includes(d.id) ? 3 : 2);

                    node.selectAll(".node-glow")
                        .attr("stroke", d => d.id === currentNodeId ? "rgba(192, 132, 252, 0.5)" :
                            possible.includes(d.id) ? "rgba(251, 191, 36, 0.4)" : "rgba(56, 189, 248, 0.3)");

                    // Update links
                    link.attr("stroke", d => d.source.id === currentNodeId ? "rgba(251, 191, 36, 0.8)" : "rgba(56, 189, 248, 0.4)")
                        .attr("marker-end", d => d.source.id === currentNodeId ? "url(#arrowActive)" : "url(#arrowGrad)");
                }

                node.on("click", (e, d) => {
                    // Only allow valid transitions or starting fresh
                    const possible = currentNodeId
                        ? links.filter(l => l.source.id === currentNodeId).map(l => l.target.id)
                        : nodes.map(n => n.id);

                    if (!possible.includes(d.id)) return;

                    currentWord += d.id + " ";
                    currentNodeId = d.id;
                    document.getElementById('sim3-output').innerText = currentWord;

                    // Pulse animation on clicked node
                    d3.select(e.currentTarget).select(".node-main")
                        .transition().duration(100)
                        .attr("r", 30)
                        .transition().duration(200)
                        .attr("r", 24);

                    updateHighlights();
                });

                document.getElementById('sim3-clear').onclick = () => {
                    currentWord = "";
                    currentNodeId = null;
                    document.getElementById('sim3-output').innerText = "";
                    updateHighlights();
                };

                // Initial highlights
                updateHighlights();
            },

            'sim-4': (container) => { // Perceptron - Enhanced with training
                let points = [];
                let w1 = 0.5, w2 = -0.5, bias = 0.1;

                function genPoints() {
                    points = [];
                    for (let i = 0; i < 10; i++) {
                        points.push({ x: Math.random()*3+1, y: Math.random()*3+1, c: 1 });
                        points.push({ x: Math.random()*3-4, y: Math.random()*3-4, c: 0 });
                    }
                }
                genPoints();

                container.innerHTML = `
                    <div style="display:flex; height:100%;">
                        <div style="flex:1; padding:20px; display:flex; flex-direction:column; gap:8px; overflow-y:auto;">
                            <div style="font-family:var(--font-mono); font-size:1rem; color:var(--accent-amber); margin-bottom:5px;">
                                f(x) = step(w1·x1 + w2·x2 + b)
                            </div>
                            <label style="font-size:0.9rem;">w1: <span id="val-w1">${w1}</span></label>
                            <input type="range" id="in-w1" min="-3" max="3" step="0.1" value="${w1}">
                            <label style="font-size:0.9rem;">w2: <span id="val-w2">${w2}</span></label>
                            <input type="range" id="in-w2" min="-3" max="3" step="0.1" value="${w2}">
                            <label style="font-size:0.9rem;">bias: <span id="val-b">${bias}</span></label>
                            <input type="range" id="in-b" min="-5" max="5" step="0.1" value="${bias}">
                            <div id="sim4-accuracy" style="font-weight:bold; color:var(--accent-green); margin-top:8px; font-size:1.1rem;"></div>
                            <div style="display:flex; gap:8px; flex-wrap:wrap; margin-top:5px;">
                                <button id="sim4-train1">Train 1 Step</button>
                                <button id="sim4-train10">Train 10 Steps</button>
                                <button id="sim4-regen">Regenerate Data</button>
                            </div>
                        </div>
                        <div id="sim4-viz" style="flex:2;"></div>
                    </div>
                `;

                const vizW = container.clientWidth * 0.6;
                const vizH = container.clientHeight;
                const svg = d3.select("#sim4-viz").append("svg").attr("width", vizW).attr("height", vizH);
                const xScale = d3.scaleLinear().domain([-5, 5]).range([0, vizW]);
                const yScale = d3.scaleLinear().domain([-5, 5]).range([vizH, 0]);

                svg.append("line").attr("x1",0).attr("x2",vizW).attr("y1",vizH/2).attr("y2",vizH/2).attr("stroke","#222");
                svg.append("line").attr("x1",vizW/2).attr("x2",vizW/2).attr("y1",0).attr("y2",vizH).attr("stroke","#222");
                const boundary = svg.append("line").attr("stroke","white").attr("stroke-width",3).attr("stroke-dasharray","8,4");
                const dotGroup = svg.append("g");

                function predict(p) { return (w1*p.x + w2*p.y + bias) >= 0 ? 1 : 0; }

                function update() {
                    document.getElementById('val-w1').innerText = w1.toFixed(2);
                    document.getElementById('val-w2').innerText = w2.toFixed(2);
                    document.getElementById('val-b').innerText = bias.toFixed(2);
                    document.getElementById('in-w1').value = w1;
                    document.getElementById('in-w2').value = w2;
                    document.getElementById('in-b').value = bias;

                    const getY = x => (-bias - w1*x) / (w2 || 0.0001);
                    boundary.attr("x1",xScale(-5)).attr("y1",yScale(getY(-5))).attr("x2",xScale(5)).attr("y2",yScale(getY(5)));

                    let correct = 0;
                    const sel = dotGroup.selectAll("g.point").data(points, (d,i)=>i);
                    const enter = sel.enter().append("g").attr("class","point");
                    enter.append("circle").attr("r",10);
                    enter.append("text").attr("dy",4).attr("text-anchor","middle").attr("font-size","12px").attr("fill","white").attr("pointer-events","none");
                    const merged = enter.merge(sel);
                    merged.attr("transform", d=>`translate(${xScale(d.x)},${yScale(d.y)})`);
                    merged.select("circle")
                        .attr("fill", d=>d.c ? "var(--accent-blue)" : "var(--accent-red)")
                        .attr("stroke", d=> { const ok = predict(d)===d.c; if(ok) correct++; return ok ? "var(--accent-green)" : "white"; })
                        .attr("stroke-width", d=> predict(d)===d.c ? 3 : 2);
                    merged.select("text").text(d=> predict(d)===d.c ? "" : "X");
                    sel.exit().remove();

                    const acc = (correct / points.length * 100).toFixed(0);
                    document.getElementById('sim4-accuracy').innerText = `Accuracy: ${acc}% (${correct}/${points.length})`;
                    document.getElementById('sim4-accuracy').style.color = correct===points.length ? 'var(--accent-green)' : 'var(--accent-amber)';
                }

                function trainStep() {
                    const lr = 0.1;
                    for (const p of points) {
                        const pred = predict(p);
                        const err = p.c - pred;
                        if (err !== 0) { w1 += lr*err*p.x; w2 += lr*err*p.y; bias += lr*err; }
                    }
                    update();
                }

                container.querySelectorAll('input[type="range"]').forEach(i => i.addEventListener('input', ()=>{
                    w1 = parseFloat(document.getElementById('in-w1').value);
                    w2 = parseFloat(document.getElementById('in-w2').value);
                    bias = parseFloat(document.getElementById('in-b').value);
                    update();
                }));
                document.getElementById('sim4-train1').onclick = trainStep;
                document.getElementById('sim4-train10').onclick = ()=>{ for(let i=0;i<10;i++) trainStep(); };
                document.getElementById('sim4-regen').onclick = ()=>{ genPoints(); w1=0.5; w2=-0.5; bias=0.1; update(); };
                update();
            },

            'sim-5': (container) => { // XOR - Two Panel
                container.innerHTML = `
                    <div style="height:100%; display:flex; flex-direction:column; padding:20px; box-sizing:border-box;">
                        <div style="display:flex; gap:20px; flex:1; min-height:0;">
                            <div style="flex:1; display:flex; flex-direction:column; align-items:center;">
                                <h3 style="margin:0 0 10px; color:var(--accent-red); font-size:1.2rem;">Input Space</h3>
                                <div id="sim5-left" style="flex:1; width:100%;"></div>
                                <div id="sim5-left-msg" style="color:var(--accent-red); font-size:0.95rem; margin-top:5px; text-align:center;">No single line can separate these classes.</div>
                            </div>
                            <div style="flex:1; display:flex; flex-direction:column; align-items:center;">
                                <h3 style="margin:0 0 10px; color:var(--text-muted); font-size:1.2rem;">Hidden Layer Space</h3>
                                <div id="sim5-right" style="flex:1; width:100%; opacity:0.3; transition:opacity 0.5s;"></div>
                                <div id="sim5-right-msg" style="color:var(--text-muted); font-size:0.95rem; margin-top:5px; text-align:center;">Waiting for hidden layer...</div>
                            </div>
                        </div>
                        <div style="text-align:center; margin-top:15px;">
                            <button id="sim5-btn">Add Hidden Layer</button>
                        </div>
                    </div>
                `;

                const points = [{x:0,y:0,c:0},{x:1,y:1,c:0},{x:0,y:1,c:1},{x:1,y:0,c:1}];
                const gridSize = 15;
                let grid = [];
                for(let i=0;i<=gridSize;i++) for(let j=0;j<=gridSize;j++) grid.push({x:i/gridSize,y:j/gridSize});

                // Left panel
                const lCont = document.getElementById('sim5-left');
                const lW = lCont.clientWidth, lH = lCont.clientHeight;
                const lSvg = d3.select("#sim5-left").append("svg").attr("width",lW).attr("height",lH);
                const lx = d3.scaleLinear().domain([-0.3,1.3]).range([20,lW-20]);
                const ly = d3.scaleLinear().domain([-0.3,1.3]).range([lH-20,20]);

                const lGrid = lSvg.selectAll(".grid").data(grid).enter().append("circle")
                    .attr("cx",d=>lx(d.x)).attr("cy",d=>ly(d.y)).attr("r",1.5).attr("fill","#333");
                lSvg.append("line").attr("x1",lx(-0.3)).attr("y1",ly(0.5)).attr("x2",lx(1.3)).attr("y2",ly(0.5))
                    .attr("stroke","var(--text-muted)").attr("stroke-width",2).attr("stroke-dasharray","6,4").attr("opacity",0.5);
                const lDots = lSvg.selectAll(".data").data(points).enter().append("circle")
                    .attr("cx",d=>lx(d.x)).attr("cy",d=>ly(d.y)).attr("r",14)
                    .attr("fill",d=>d.c?"var(--accent-blue)":"var(--accent-red)")
                    .attr("stroke","white").attr("stroke-width",2);
                lSvg.selectAll(".lbl").data(points).enter().append("text")
                    .attr("x",d=>lx(d.x)).attr("y",d=>ly(d.y)-20).attr("text-anchor","middle")
                    .attr("fill","var(--text-muted)").attr("font-size","11px")
                    .text(d=>`(${d.x},${d.y})`);

                // Right panel
                const rCont = document.getElementById('sim5-right');
                const rW = rCont.clientWidth, rH = rCont.clientHeight;
                const rSvg = d3.select("#sim5-right").append("svg").attr("width",rW).attr("height",rH);
                const rx = d3.scaleLinear().domain([-0.3,1.5]).range([20,rW-20]);
                const ry = d3.scaleLinear().domain([-0.5,1.3]).range([rH-20,20]);

                // Transformed coords: h1 = relu(x+y-0.5), h2 = relu(x+y-1.5)
                const txf = d => ({ h1: Math.max(0, d.x+d.y-0.5), h2: Math.max(0, d.x+d.y-1.5) });
                const tPoints = points.map(p=>({...txf(p), c:p.c}));

                const rGrid = rSvg.selectAll(".rgrid").data(grid).enter().append("circle")
                    .attr("cx",d=>rx(txf(d).h1)).attr("cy",d=>ry(txf(d).h2)).attr("r",1.5).attr("fill","#333").attr("opacity",0);
                const rDots = rSvg.selectAll(".rdata").data(tPoints).enter().append("circle")
                    .attr("cx",d=>rx(d.h1)).attr("cy",d=>ry(d.h2)).attr("r",14)
                    .attr("fill",d=>d.c?"var(--accent-blue)":"var(--accent-red)")
                    .attr("stroke","white").attr("stroke-width",2).attr("opacity",0);
                const rLine = rSvg.append("line").attr("stroke","var(--accent-green)").attr("stroke-width",3).attr("opacity",0);

                let active = false;
                document.getElementById('sim5-btn').onclick = () => {
                    active = !active;
                    const t = d3.transition().duration(2000).ease(d3.easeCubicInOut);
                    if (active) {
                        // Warp left grid
                        lGrid.transition(t).attr("cx",d=>lx(txf(d).h1*0.8+d.x*0.2)).attr("cy",d=>ly(txf(d).h2*0.8+d.y*0.2)).attr("fill","#444");
                        // Show right panel
                        document.getElementById('sim5-right').style.opacity = '1';
                        rGrid.transition(t).attr("opacity",0.4);
                        rDots.transition(t).attr("opacity",1);
                        rLine.transition(t).delay(1500)
                            .attr("x1",rx(-0.1)).attr("y1",ry(0.3)).attr("x2",rx(1.3)).attr("y2",ry(-0.1)).attr("opacity",1);
                        document.getElementById('sim5-left-msg').textContent = 'Grid warped by hidden layer!';
                        document.getElementById('sim5-left-msg').style.color = 'var(--accent-amber)';
                        document.getElementById('sim5-right-msg').textContent = 'Hidden layer transforms the space. Now separable!';
                        document.getElementById('sim5-right-msg').style.color = 'var(--accent-green)';
                        document.getElementById('sim5-btn').textContent = 'Remove Hidden Layer';
                    } else {
                        lGrid.transition(t).attr("cx",d=>lx(d.x)).attr("cy",d=>ly(d.y)).attr("fill","#333");
                        rGrid.transition(t).attr("opacity",0);
                        rDots.transition(t).attr("opacity",0);
                        rLine.transition(t).attr("opacity",0);
                        document.getElementById('sim5-right').style.opacity = '0.3';
                        document.getElementById('sim5-left-msg').textContent = 'No single line can separate these classes.';
                        document.getElementById('sim5-left-msg').style.color = 'var(--accent-red)';
                        document.getElementById('sim5-right-msg').textContent = 'Waiting for hidden layer...';
                        document.getElementById('sim5-right-msg').style.color = 'var(--text-muted)';
                        document.getElementById('sim5-btn').textContent = 'Add Hidden Layer';
                    }
                };
            },

            'sim-6': (container) => { // Backpropagation - Enhanced
                container.innerHTML = `
                    <div style="height:100%; display:flex; flex-direction:column; padding:20px; box-sizing:border-box;">
                        <div id="sim6-viz" style="flex:1; min-height:0;"></div>
                        <div style="text-align:center; padding:10px 0;">
                            <div id="sim6-stage" style="font-family:var(--font-mono); font-size:1rem; color:var(--text-secondary); min-height:25px; margin-bottom:10px;"></div>
                            <div style="display:flex; gap:10px; justify-content:center; align-items:center;">
                                <button id="sim6-btn">Train Step</button>
                                <button id="sim6-btn10">Train 10 Steps</button>
                                <button id="sim6-reset">Reset</button>
                                <span style="font-family:var(--font-mono); margin-left:15px;">Target: <span style="color:var(--accent-green);">1.0</span> | Predicted: <span id="sim6-pred" style="color:var(--accent-amber);">?</span> | Loss: <span id="sim6-loss" style="color:var(--accent-red);">?</span></span>
                            </div>
                        </div>
                    </div>
                `;

                const w = container.clientWidth;
                const h = container.clientHeight * 0.7;
                const svg = d3.select("#sim6-viz").append("svg").attr("width", w).attr("height", h);

                const layerSizes = [3, 4, 4, 1];
                const layerX = layerSizes.map((_, i) => w * (0.12 + i * 0.25));
                const target = 1.0;

                let weights = [], activations = [];
                function initNetwork() {
                    weights = [];
                    for (let l = 0; l < layerSizes.length - 1; l++) {
                        const lw = [];
                        for (let i = 0; i < layerSizes[l]; i++) {
                            const row = [];
                            for (let j = 0; j < layerSizes[l+1]; j++) row.push((Math.random()-0.5)*2);
                            lw.push(row);
                        }
                        weights.push(lw);
                    }
                    activations = layerSizes.map((s, i) => {
                        if (i===0) return [0.5, 0.8, 0.3];
                        return new Array(s).fill(0);
                    });
                }
                initNetwork();

                function sigmoid(x) { return 1/(1+Math.exp(-x)); }

                function forward() {
                    for (let l = 0; l < weights.length; l++) {
                        for (let j = 0; j < layerSizes[l+1]; j++) {
                            let sum = 0;
                            for (let i = 0; i < layerSizes[l]; i++) sum += activations[l][i] * weights[l][i][j];
                            activations[l+1][j] = sigmoid(sum);
                        }
                    }
                    return activations[activations.length-1][0];
                }

                const nodes = [];
                layerSizes.forEach((count, li) => {
                    for (let i = 0; i < count; i++) {
                        nodes.push({ layer:li, idx:i, x:layerX[li], y:h/2 + (i-(count-1)/2)*60 });
                    }
                });
                const links = [];
                nodes.forEach(src => nodes.forEach(dst => {
                    if (dst.layer === src.layer+1) links.push({src,dst,li:src.layer,si:src.idx,di:dst.idx});
                }));

                const linkSel = svg.selectAll("line.link").data(links).enter().append("line").attr("class","link")
                    .attr("x1",d=>d.src.x).attr("y1",d=>d.src.y).attr("x2",d=>d.dst.x).attr("y2",d=>d.dst.y)
                    .attr("stroke","#444").attr("stroke-width",1.5);

                const wLabels = svg.selectAll("text.wt").data(links).enter().append("text").attr("class","wt")
                    .attr("x",d=>(d.src.x+d.dst.x)/2).attr("y",d=>(d.src.y+d.dst.y)/2-3)
                    .attr("text-anchor","middle").attr("fill","var(--text-muted)").attr("font-size","9px").attr("font-family","var(--font-mono)");

                const nodeG = svg.selectAll("g.node").data(nodes).enter().append("g").attr("class","node")
                    .attr("transform",d=>`translate(${d.x},${d.y})`);
                nodeG.append("circle").attr("r",18).attr("fill","var(--bg-elevated)").attr("stroke","var(--accent-blue)").attr("stroke-width",2);
                const nodeVals = nodeG.append("text").attr("dy",4).attr("text-anchor","middle").attr("fill","white").attr("font-size","10px").attr("font-family","var(--font-mono)");

                const layerLabels = ["Input","Hidden 1","Hidden 2","Output"];
                layerSizes.forEach((_, li) => {
                    svg.append("text").attr("x",layerX[li]).attr("y",h-10).attr("text-anchor","middle").attr("fill","var(--text-muted)").attr("font-size","11px").text(layerLabels[li]);
                });

                function renderState() {
                    const pred = forward();
                    nodeVals.text(d=>activations[d.layer][d.idx].toFixed(2));
                    wLabels.text(d=>weights[d.li][d.si][d.di].toFixed(2));
                    const loss = Math.pow(target - pred, 2);
                    document.getElementById('sim6-pred').innerText = pred.toFixed(3);
                    document.getElementById('sim6-loss').innerText = loss.toFixed(4);
                    document.getElementById('sim6-loss').style.color = loss < 0.01 ? 'var(--accent-green)' : 'var(--accent-red)';
                }

                function animateTrainStep(callback) {
                    const stage = document.getElementById('sim6-stage');
                    stage.innerText = "Forward Pass: Computing activations...";
                    stage.style.color = "var(--accent-blue)";
                    linkSel.transition().duration(400).delay(d=>d.src.layer*300).attr("stroke","var(--accent-blue)").attr("stroke-width",3)
                        .transition().duration(300).attr("stroke","#444").attr("stroke-width",1.5);
                    nodeG.select("circle").transition().duration(300).delay(d=>d.layer*300).attr("fill","rgba(56,189,248,0.3)")
                        .transition().duration(300).attr("fill","var(--bg-elevated)");

                    setTimeout(()=>{
                        const pred = forward();
                        renderState();
                        const loss = Math.pow(target - pred, 2);
                        stage.innerText = `Comparing: Predicted ${pred.toFixed(3)}, Target ${target.toFixed(1)}, Loss: ${loss.toFixed(4)}`;
                        stage.style.color = loss < 0.05 ? "var(--accent-green)" : "var(--accent-amber)";
                    }, 1200);

                    setTimeout(()=>{
                        stage.innerText = "Backward Pass: Computing gradients...";
                        stage.style.color = "var(--accent-red)";
                        linkSel.transition().duration(400).delay(d=>(weights.length-1-d.src.layer)*300).attr("stroke","var(--accent-red)").attr("stroke-width",3)
                            .transition().duration(300).attr("stroke","#444").attr("stroke-width",1.5);
                    }, 2000);

                    setTimeout(()=>{
                        // Actual weight update (simple gradient descent)
                        const lr = 0.5;
                        const pred = activations[activations.length-1][0];
                        const err = pred - target;
                        // Simplified backprop for visualization
                        for (let l = weights.length-1; l >= 0; l--) {
                            for (let i = 0; i < layerSizes[l]; i++) {
                                for (let j = 0; j < layerSizes[l+1]; j++) {
                                    const grad = err * activations[l][i] * activations[l+1][j] * (1 - activations[l+1][j]);
                                    weights[l][i][j] -= lr * grad * (0.5 + Math.random()*0.5);
                                }
                            }
                        }
                        const newPred = forward();
                        const newLoss = Math.pow(target - newPred, 2);
                        stage.innerText = `Weights Updated! Loss: ${newLoss.toFixed(4)}`;
                        stage.style.color = "var(--accent-green)";
                        renderState();
                        if (callback) callback();
                    }, 3200);
                }

                document.getElementById('sim6-btn').onclick = () => animateTrainStep();
                document.getElementById('sim6-btn10').onclick = () => {
                    let i = 0;
                    function step() { if (i++ < 10) { const lr=0.5; const pred=forward(); const err=pred-target; for(let l=weights.length-1;l>=0;l--) for(let ii=0;ii<layerSizes[l];ii++) for(let j=0;j<layerSizes[l+1];j++) { const g=err*activations[l][ii]*activations[l+1][j]*(1-activations[l+1][j]); weights[l][ii][j]-=lr*g*(0.5+Math.random()*0.5); } forward(); } }
                    for(let k=0;k<10;k++) step();
                    renderState();
                    document.getElementById('sim6-stage').innerText = 'Trained 10 steps!';
                    document.getElementById('sim6-stage').style.color = 'var(--accent-green)';
                };
                document.getElementById('sim6-reset').onclick = () => { initNetwork(); renderState(); document.getElementById('sim6-stage').innerText=''; };
                renderState();
            },

            'sim-7': (container) => { // Vanishing Gradient - Enhanced
                container.innerHTML = `
                    <div style="height:100%; display:flex; flex-direction:column; padding:15px; box-sizing:border-box;">
                        <div style="text-align:center; padding:5px 0;">
                            <label style="font-size:1rem;">Weight/Activation Magnitude: <span id="sim7-val" style="color:var(--accent-amber); font-weight:bold;">0.5</span></label>
                            <input type="range" id="sim7-slider" min="0.1" max="1.5" step="0.05" value="0.5" style="max-width:400px;">
                        </div>
                        <div id="sim7-msg" style="text-align:center; font-size:1rem; min-height:25px; padding:5px;"></div>
                        <div style="flex:1; min-height:0; display:flex; flex-direction:column; gap:10px;">
                            <div style="flex:1; min-height:0;">
                                <div style="color:var(--text-muted); font-size:0.85rem; margin-bottom:5px;">Standard Network</div>
                                <div id="sim7-viz" style="width:100%; height:calc(100% - 20px);"></div>
                            </div>
                            <div style="flex:1; min-height:0;">
                                <div style="color:var(--text-muted); font-size:0.85rem; margin-bottom:5px;">With Residual Connection (gradient = 1.0 always)</div>
                                <div id="sim7-viz2" style="width:100%; height:calc(100% - 20px);"></div>
                            </div>
                        </div>
                    </div>
                `;

                const numLayers = 8;
                function drawNetwork(containerId, getGradients) {
                    const el = document.getElementById(containerId);
                    const w = el.clientWidth, h = el.clientHeight;
                    const svg = d3.select('#'+containerId).append("svg").attr("width",w).attr("height",h);
                    const layerStep = w / (numLayers + 1);
                    const barH = h * 0.5;
                    const nodeY = h * 0.25;
                    const barY = h * 0.55;

                    const layers = d3.range(numLayers).map(i=>({x:(i+1)*layerStep, i}));

                    // Connection lines
                    svg.selectAll("line.conn").data(layers.slice(0,-1)).enter().append("line").attr("class","conn")
                        .attr("x1",d=>d.x+12).attr("y1",nodeY).attr("x2",(d,i)=>layers[i+1].x-12).attr("y2",nodeY).attr("stroke","#444").attr("stroke-width",2);

                    // Nodes
                    const circles = svg.selectAll("circle").data(layers).enter().append("circle")
                        .attr("cx",d=>d.x).attr("cy",nodeY).attr("r",12).attr("fill","#555").attr("stroke","#666").attr("stroke-width",1);

                    // Gradient bars
                    const bars = svg.selectAll("rect.bar").data(layers).enter().append("rect").attr("class","bar")
                        .attr("x",d=>d.x-10).attr("width",20).attr("rx",3);

                    // Bar labels
                    const barLabels = svg.selectAll("text.barlbl").data(layers).enter().append("text").attr("class","barlbl")
                        .attr("x",d=>d.x).attr("text-anchor","middle").attr("fill","white").attr("font-size","9px").attr("font-family","var(--font-mono)");

                    // Layer label
                    svg.selectAll("text.llbl").data(layers).enter().append("text").attr("class","llbl")
                        .attr("x",d=>d.x).attr("y",nodeY+30).attr("text-anchor","middle").attr("fill","var(--text-muted)").attr("font-size","9px")
                        .text(d=>`L${numLayers-d.i}`);

                    return { circles, bars, barLabels, barY, barH };
                }

                const net1 = drawNetwork('sim7-viz', null);
                const net2 = drawNetwork('sim7-viz2', null);

                function update() {
                    const grad = parseFloat(document.getElementById('sim7-slider').value);
                    document.getElementById('sim7-val').innerText = grad.toFixed(2);

                    // Standard network gradients
                    const grads1 = [];
                    let curr = 1.0;
                    for (let i = 0; i < numLayers; i++) { grads1.push(curr); curr *= grad; }
                    grads1.reverse();

                    // Residual network: always ~1.0
                    const grads2 = new Array(numLayers).fill(1.0);

                    function applyViz(net, grads) {
                        const maxG = Math.max(...grads, 1);
                        net.circles.data(grads)
                            .transition().duration(300)
                            .attr("fill", d => d < 0.01 ? "#222" : d > 1.5 ? "var(--accent-red)" : d > 0.1 ? "var(--accent-green)" : "var(--accent-amber)")
                            .attr("r", d => 6 + Math.min(14, d/maxG * 12));
                        net.bars.data(grads)
                            .transition().duration(300)
                            .attr("y", d => net.barY + net.barH - Math.min(net.barH, (d/maxG)*net.barH))
                            .attr("height", d => Math.min(net.barH, (d/maxG)*net.barH))
                            .attr("fill", d => d < 0.01 ? "var(--accent-red)" : d < 0.1 ? "var(--accent-amber)" : "var(--accent-green)");
                        net.barLabels.data(grads)
                            .text(d => d >= 0.01 ? d.toFixed(2) : d.toExponential(0))
                            .attr("y", d => net.barY + net.barH - Math.min(net.barH, (d/maxG)*net.barH) - 4);
                    }

                    applyViz(net1, grads1);
                    applyViz(net2, grads2);

                    const msg = document.getElementById('sim7-msg');
                    if (grad < 0.7) { msg.innerHTML = '<span style="color:var(--accent-red);">Gradients vanish! Early layers cannot learn.</span>'; }
                    else if (grad > 1.1) { msg.innerHTML = '<span style="color:var(--accent-red);">Gradients explode! Training becomes unstable.</span>'; }
                    else { msg.innerHTML = '<span style="color:var(--accent-green);">Gradients stable. All layers learn equally.</span>'; }
                }

                document.getElementById('sim7-slider').oninput = update;
                update();
            },

            'sim-8': (container) => { // RNN Unrolled - Enhanced
                container.innerHTML = `
                    <div style="height:100%; display:flex; flex-direction:column; padding:15px; box-sizing:border-box;">
                        <div id="sim8-viz" style="flex:1; min-height:0;"></div>
                        <div id="sim8-bars" style="height:80px; width:100%;"></div>
                        <div id="sim8-annotation" style="text-align:center; color:var(--text-secondary); font-size:0.95rem; min-height:40px; padding:5px;"></div>
                        <div style="display:flex; gap:10px; justify-content:center; padding:10px 0;">
                            <button id="sim8-btn">Process Sequence (RNN)</button>
                            <button id="sim8-btn2">Process with LSTM</button>
                        </div>
                    </div>
                `;

                const steps = ["The","cat","sat","on","the","mat"];
                const vW = container.clientWidth, vH = container.clientHeight * 0.45;
                const svg = d3.select("#sim8-viz").append("svg").attr("width",vW).attr("height",vH);
                const stepW = vW / (steps.length + 1);
                const cy = vH * 0.45;

                // Arrows between steps
                const defs = svg.append("defs");
                defs.append("marker").attr("id","rnnArr").attr("viewBox","0 -4 8 8").attr("refX",8).attr("refY",0)
                    .attr("markerWidth",6).attr("markerHeight",6).attr("orient","auto")
                    .append("path").attr("d","M0,-4L8,0L0,4").attr("fill","var(--accent-blue)");

                steps.slice(0,-1).forEach((_, i) => {
                    svg.append("line").attr("x1",(i+1)*stepW+22).attr("y1",cy).attr("x2",(i+2)*stepW-22).attr("y2",cy)
                        .attr("stroke","#555").attr("stroke-width",2).attr("marker-end","url(#rnnArr)");
                });

                const gs = svg.selectAll("g.step").data(steps).enter().append("g").attr("class","step")
                    .attr("transform",(d,i)=>`translate(${(i+1)*stepW},${cy})`);
                gs.append("text").text(d=>d).attr("y",55).attr("text-anchor","middle").attr("fill","white").attr("font-size","1rem");
                const hiddens = gs.append("circle").attr("r",20).attr("fill","var(--bg-elevated)").attr("stroke","var(--accent-blue)").attr("stroke-width",2);

                // Memory strength bars
                const barSvg = d3.select("#sim8-bars").append("svg").attr("width",vW).attr("height",80);
                const memBars = barSvg.selectAll("g.mem").data(steps).enter().append("g").attr("class","mem")
                    .attr("transform",(d,i)=>`translate(${(i+1)*stepW},5)`);
                memBars.append("rect").attr("x",-15).attr("width",30).attr("height",0).attr("fill","var(--accent-blue)").attr("rx",3).attr("class","membar");
                memBars.append("text").attr("y",65).attr("text-anchor","middle").attr("fill","var(--text-muted)").attr("font-size","10px").attr("class","memlbl");

                function animateRNN(isLSTM) {
                    hiddens.attr("fill","var(--bg-elevated)").attr("opacity",1);
                    memBars.select(".membar").attr("height",0);
                    memBars.select(".memlbl").text("");
                    document.getElementById('sim8-annotation').innerText = '';

                    const rnnDecay = [100, 60, 36, 22, 13, 8];
                    const lstmDecay = [100, 95, 92, 90, 88, 87];
                    const decay = isLSTM ? lstmDecay : rnnDecay;
                    const color = isLSTM ? "var(--accent-green)" : "var(--accent-blue)";

                    steps.forEach((_, i) => {
                        setTimeout(() => {
                            const alpha = decay[i] / 100;
                            hiddens.filter((_,j)=>j===i)
                                .transition().duration(300).attr("fill", color).attr("opacity", alpha)
                                .attr("stroke", color);
                        }, i * 500);
                    });

                    setTimeout(() => {
                        steps.forEach((_, i) => {
                            const pct = decay[i];
                            memBars.filter((_,j)=>j===i).select(".membar")
                                .transition().duration(400).attr("height", pct*0.5)
                                .attr("fill", pct > 50 ? "var(--accent-green)" : pct > 20 ? "var(--accent-amber)" : "var(--accent-red)");
                            memBars.filter((_,j)=>j===i).select(".memlbl").text(pct+"%");
                        });

                        if (!isLSTM) {
                            document.getElementById('sim8-annotation').innerHTML =
                                'By the time the RNN reaches "mat", it has mostly forgotten "The". <span style="color:var(--accent-red);">Vanishing gradient through time.</span>';
                        } else {
                            document.getElementById('sim8-annotation').innerHTML =
                                'LSTM gates preserve the signal. <span style="color:var(--accent-green);">Memory strength stays above 85% throughout.</span>';
                        }
                    }, steps.length * 500 + 200);
                }

                document.getElementById('sim8-btn').onclick = () => animateRNN(false);
                document.getElementById('sim8-btn2').onclick = () => animateRNN(true);
            },

            'sim-9': (container) => { // Embeddings - Two Panel Rebuild
                container.innerHTML = `
                    <div style="height:100%; display:flex; flex-direction:column; padding:20px; box-sizing:border-box;">
                        <div style="display:flex; gap:20px; flex:1; min-height:0;">
                            <div style="flex:1; display:flex; flex-direction:column; align-items:center;">
                                <h3 style="margin:0 0 10px; font-size:1.2rem;">One-Hot Encoding</h3>
                                <div style="font-size:0.85rem; color:var(--text-muted); margin-bottom:8px;">Dimensions: 50,000</div>
                                <div id="sim9-onehot" style="flex:1; width:100%; overflow:hidden;"></div>
                            </div>
                            <div style="flex:1; display:flex; flex-direction:column; align-items:center;">
                                <h3 style="margin:0 0 10px; font-size:1.2rem;">Learned Embeddings</h3>
                                <div style="font-size:0.85rem; color:var(--text-muted); margin-bottom:8px;">Dimensions: 512 (down from 50,000!)</div>
                                <div id="sim9-embed" style="flex:1; width:100%;"></div>
                            </div>
                        </div>
                        <div style="text-align:center; margin-top:10px;">
                            <button id="sim9-btn">Learn Embeddings</button>
                            <div id="sim9-arithmetic" style="margin-top:10px; font-family:var(--font-mono); font-size:1.1rem; color:var(--text-secondary); min-height:25px;"></div>
                        </div>
                    </div>
                `;

                const words = ["cat","dog","king","queen","apple"];
                const colors = {"cat":"#f59e0b","dog":"#f59e0b","king":"#a855f7","queen":"#a855f7","apple":"#22c55e"};
                const embedPos = {"cat":[0.2,0.3],"dog":[0.3,0.35],"king":[0.7,0.8],"queen":[0.75,0.75],"apple":[0.5,0.15]};

                // One-hot matrix
                const oh = document.getElementById('sim9-onehot');
                const grid = document.createElement('div');
                grid.style.cssText = 'display:grid; grid-template-columns:60px repeat(5,1fr); gap:2px; font-family:var(--font-mono); font-size:0.8rem; padding:10px;';
                grid.innerHTML = '<div></div>' + words.map(w=>`<div style="text-align:center;color:var(--text-muted);font-size:0.7rem;">${w}</div>`).join('');
                words.forEach((word, wi) => {
                    grid.innerHTML += `<div style="color:${colors[word]}; font-size:0.85rem;">${word}</div>`;
                    words.forEach((_, ci) => {
                        const isOne = wi === ci;
                        grid.innerHTML += `<div id="oh-${wi}-${ci}" style="text-align:center; background:${isOne?'var(--accent-amber)':'var(--bg-surface)'}; color:${isOne?'black':'#555'}; padding:8px; border-radius:4px; font-weight:${isOne?'bold':'normal'}; transition:all 0.5s;">${isOne?'1':'0'}</div>`;
                    });
                });
                oh.appendChild(grid);

                // Embedding scatter
                const eW = document.getElementById('sim9-embed').clientWidth;
                const eH = document.getElementById('sim9-embed').clientHeight;
                const eSvg = d3.select("#sim9-embed").append("svg").attr("width",eW).attr("height",eH);
                const ex = d3.scaleLinear().domain([0,1]).range([40,eW-40]);
                const ey = d3.scaleLinear().domain([0,1]).range([eH-40,40]);

                const eDots = eSvg.selectAll("g.edot").data(words).enter().append("g").attr("class","edot")
                    .attr("transform", d=>`translate(${ex(embedPos[d][0])},${ey(embedPos[d][1])})`).attr("opacity",0);
                eDots.append("circle").attr("r",8).attr("fill",d=>colors[d]);
                eDots.append("text").text(d=>d).attr("dy",-14).attr("text-anchor","middle").attr("fill","white").attr("font-size","12px");

                // Relationship lines
                const rels = [["cat","dog"],["king","queen"]];
                const relLines = eSvg.selectAll("line.rel").data(rels).enter().append("line").attr("class","rel")
                    .attr("x1",d=>ex(embedPos[d[0]][0])).attr("y1",d=>ey(embedPos[d[0]][1]))
                    .attr("x2",d=>ex(embedPos[d[1]][0])).attr("y2",d=>ey(embedPos[d[1]][1]))
                    .attr("stroke","#555").attr("stroke-dasharray","4").attr("opacity",0);

                document.getElementById('sim9-btn').onclick = () => {
                    eDots.transition().duration(1000).delay((d,i)=>i*200).attr("opacity",1);
                    relLines.transition().duration(500).delay(1200).attr("opacity",0.6);
                    setTimeout(()=>{
                        document.getElementById('sim9-arithmetic').innerHTML = '<span style="color:#a855f7;">king</span> - <span style="color:var(--accent-blue);">man</span> + <span style="color:var(--accent-blue);">woman</span> = <span style="color:#a855f7;">queen</span>';
                    }, 1800);
                };
            },

            'sim-10': (container) => { // Attention (Seq2Seq) - Enhanced
                container.innerHTML = `
                    <div style="height:100%; display:flex; flex-direction:column; align-items:center; padding:15px; box-sizing:border-box;">
                        <div style="margin-bottom:10px; color:var(--text-secondary); font-size:0.95rem;">Click a Decoder word to see attention weights</div>
                        <div id="sim10-viz" style="width:100%; flex:1; min-height:0;"></div>
                    </div>
                `;

                const w = container.clientWidth;
                const h = container.clientHeight * 0.85;
                const svg = d3.select("#sim10-viz").append("svg").attr("width",w).attr("height",h);

                // SVG filter for glow
                const defs = svg.append("defs");
                const glowF = defs.append("filter").attr("id","attnGlow");
                glowF.append("feGaussianBlur").attr("stdDeviation","3").attr("result","blur");
                const fm = glowF.append("feMerge");
                fm.append("feMergeNode").attr("in","blur");
                fm.append("feMergeNode").attr("in","SourceGraphic");

                const encWords = ["Le","chat","est","assis","sur","le","tapis"];
                const decWords = ["The","cat","is","sitting","on","the","mat"];

                const encX = d3.scalePoint().domain(encWords).range([w*0.08,w*0.92]);
                const decX = d3.scalePoint().domain(decWords).range([w*0.08,w*0.92]);
                const encY = h*0.15, decY = h*0.85;

                const attentionWeights = {
                    "The":[0.85,0.02,0.02,0.01,0.01,0.08,0.01],
                    "cat":[0.02,0.90,0.01,0.01,0.01,0.03,0.02],
                    "is":[0.02,0.02,0.85,0.05,0.02,0.02,0.02],
                    "sitting":[0.01,0.02,0.05,0.85,0.03,0.02,0.02],
                    "on":[0.02,0.01,0.02,0.03,0.88,0.02,0.02],
                    "the":[0.08,0.02,0.02,0.01,0.02,0.82,0.03],
                    "mat":[0.01,0.02,0.02,0.02,0.02,0.03,0.88]
                };

                // Encoder nodes
                const encG = svg.selectAll("g.enc").data(encWords).enter().append("g").attr("class","enc")
                    .attr("transform",d=>`translate(${encX(d)},${encY})`);
                encG.append("circle").attr("r",18).attr("fill","var(--bg-elevated)").attr("stroke","var(--accent-blue)").attr("stroke-width",2);
                encG.append("text").text(d=>d).attr("dy",-28).attr("text-anchor","middle").attr("fill","var(--accent-blue)").attr("font-size","1rem").attr("font-weight","600");

                // Decoder nodes
                const decG = svg.selectAll("g.dec").data(decWords).enter().append("g").attr("class","dec")
                    .attr("transform",d=>`translate(${decX(d)},${decY})`).style("cursor","pointer");
                decG.append("circle").attr("r",18).attr("fill","var(--bg-elevated)").attr("stroke","var(--accent-green)").attr("stroke-width",2).attr("class","dec-circle");
                decG.append("text").text(d=>d).attr("dy",35).attr("text-anchor","middle").attr("fill","var(--accent-green)").attr("font-size","1rem").attr("font-weight","600");

                svg.append("text").attr("x",w*0.02).attr("y",encY).attr("fill","var(--text-muted)").attr("font-size","11px").text("FR");
                svg.append("text").attr("x",w*0.02).attr("y",decY).attr("fill","var(--text-muted)").attr("font-size","11px").text("EN");

                const linesGroup = svg.append("g");
                let activeDecWord = null;

                function showAttention(d) {
                    if (activeDecWord === d) return;
                    activeDecWord = d;
                    const weights = attentionWeights[d];
                    const maxW = Math.max(...weights);

                    // Fade out old
                    linesGroup.selectAll("*").transition().duration(200).attr("opacity",0).remove();

                    // Reset decoder styling
                    decG.select(".dec-circle").attr("stroke","var(--accent-green)").attr("stroke-width",2).attr("filter","none");
                    decG.filter(dd=>dd===d).select(".dec-circle").attr("stroke","var(--accent-amber)").attr("stroke-width",3).attr("filter","url(#attnGlow)");

                    // Draw curved lines with delay
                    setTimeout(()=>{
                        encWords.forEach((ew,i)=>{
                            const wt = weights[i];
                            if (wt < 0.01) return;
                            const x1 = decX(d), y1 = decY - 18;
                            const x2 = encX(ew), y2 = encY + 18;
                            const curveOff = -30 - Math.abs(x2-x1)*0.15;
                            const cx = (x1+x2)/2, cy = (y1+y2)/2 + curveOff;

                            const path = linesGroup.append("path")
                                .attr("d",`M${x1},${y1} Q${cx},${cy} ${x2},${y2}`)
                                .attr("fill","none")
                                .attr("stroke","var(--accent-amber)")
                                .attr("stroke-width", 1.5 + wt * 4.5)
                                .attr("opacity",0)
                                .attr("stroke-linecap","round");

                            if (wt === maxW) path.attr("filter","url(#attnGlow)");

                            path.transition().duration(300).attr("opacity", Math.max(0.3, wt));

                            // Weight label
                            if (wt > 0.03) {
                                linesGroup.append("text").attr("x",cx).attr("y",cy-8)
                                    .attr("text-anchor","middle").attr("fill","var(--accent-amber)")
                                    .attr("font-size","10px").attr("font-family","var(--font-mono)")
                                    .attr("opacity",0).text((wt*100).toFixed(0)+"%")
                                    .transition().delay(200).duration(200).attr("opacity",1);
                            }
                        });
                    }, 200);
                }

                decG.on("click", (e,d) => showAttention(d));
                showAttention("cat");
            },

            'sim-11': (container) => { // Tokenization - Enhanced BPE
                const tokenMap = {
                    "the":["the"],"transformer":["trans","former"],"is":["is"],"a":["a"],"an":["an"],
                    "unbelievable":["un","believ","able"],"artificial":["art","ificial"],
                    "intelligence":["intelli","gence"],"neural":["neural"],"network":["net","work"],
                    "attention":["attention"],"embedding":["embed","ding"],"hello":["hello"],
                    "world":["world"],"machine":["machine"],"learning":["learn","ing"],
                    "deep":["deep"],"model":["model"],"language":["language"],
                    "processing":["process","ing"],"natural":["natural"],"computer":["com","puter"],
                    "science":["science"],"prediction":["predict","ion"],"generation":["generat","ion"],
                    "cat":["cat"],"sat":["sat"],"on":["on"],"mat":["mat"],
                    "understanding":["under","stand","ing"],"classification":["classif","ication"]
                };
                const tokenIds = {};
                let nextId = 1000;
                Object.entries(tokenMap).forEach(([word, parts]) => {
                    parts.forEach(p => { if (!tokenIds[p]) tokenIds[p] = nextId++; });
                });

                container.innerHTML = `
                    <div style="height:100%; display:flex; flex-direction:column; align-items:center; padding:30px; box-sizing:border-box;">
                        <input type="text" id="sim11-input" value="The transformer is unbelievable" style="padding:12px; font-size:1.4rem; width:80%; text-align:center; background:var(--bg-surface); color:white; border:1px solid var(--glass-border); border-radius:8px;">
                        <div id="sim11-tokens" style="display:flex; flex-wrap:wrap; justify-content:center; gap:8px; margin-top:30px; min-height:60px;"></div>
                        <div id="sim11-ids" style="display:flex; flex-wrap:wrap; justify-content:center; gap:8px; margin-top:15px; font-family:var(--font-mono); color:var(--accent-blue); min-height:30px;"></div>
                        <div id="sim11-count" style="margin-top:15px; font-family:var(--font-mono); color:var(--text-muted); font-size:0.95rem;"></div>
                    </div>
                `;

                function tokenize(text) {
                    const words = text.toLowerCase().split(/\s+/).filter(w=>w);
                    const result = [];
                    words.forEach(word => {
                        const clean = word.replace(/[^a-z]/g,'');
                        if (!clean) return;
                        if (tokenMap[clean]) {
                            tokenMap[clean].forEach((tok,i) => {
                                result.push({ token:tok, id:tokenIds[tok], isSubword: tokenMap[clean].length > 1, isFirst: i===0, word:clean });
                            });
                        } else {
                            // Character-level fallback
                            clean.split('').forEach((ch,i)=>{
                                if (!tokenIds[ch]) tokenIds[ch] = nextId++;
                                result.push({ token:ch, id:tokenIds[ch], isSubword:true, isFirst:i===0, word:clean });
                            });
                        }
                    });
                    return result;
                }

                function render() {
                    const text = document.getElementById('sim11-input').value;
                    const tokens = tokenize(text);
                    const tokenDiv = document.getElementById('sim11-tokens');
                    const idDiv = document.getElementById('sim11-ids');
                    tokenDiv.innerHTML = '';
                    idDiv.innerHTML = '';

                    tokens.forEach((t, i) => {
                        const d = document.createElement('div');
                        d.style.cssText = `padding:10px 16px; background:var(--bg-surface); border-radius:8px; font-family:var(--font-mono); font-size:1.1rem; transition:all 0.3s; opacity:0; transform:translateY(10px);`;
                        d.style.border = t.isSubword ? '2px solid var(--accent-purple)' : '2px solid var(--accent-blue)';
                        if (t.isSubword && !t.isFirst) d.style.marginLeft = '-4px';
                        d.innerText = t.token;
                        tokenDiv.appendChild(d);
                        setTimeout(()=>{ d.style.opacity='1'; d.style.transform='translateY(0)'; }, i*80);

                        const idEl = document.createElement('div');
                        idEl.style.cssText = `min-width:50px; text-align:center; font-size:0.85rem; opacity:0; transition:opacity 0.3s;`;
                        idEl.innerText = t.id;
                        idDiv.appendChild(idEl);
                        setTimeout(()=>{ idEl.style.opacity='1'; }, i*80+200);
                    });

                    document.getElementById('sim11-count').innerText = `Total tokens: ${tokens.length} | ${tokens.filter(t=>!t.isSubword || t.isFirst).length} words`;
                }

                let debounce;
                document.getElementById('sim11-input').addEventListener('input', ()=>{
                    clearTimeout(debounce);
                    debounce = setTimeout(render, 300);
                });
                render();
            },

            'sim-12': (container) => { // Embeddings Lookup - Enhanced
                const tokenData = [
                    {word:"cat",id:2056},{word:"dog",id:3241},{word:"king",id:1087},{word:"the",id:42},{word:"sat",id:5123}
                ];
                let activeIdx = 0;

                container.innerHTML = `
                    <div style="height:100%; display:flex; flex-direction:row; align-items:center; padding:30px; box-sizing:border-box; gap:20px;">
                        <div style="flex:1; display:flex; flex-direction:column; align-items:center;">
                            <div style="font-family:var(--font-mono); margin-bottom:10px; font-size:0.9rem; color:var(--text-muted);">Embedding Matrix (50,000 rows)</div>
                            <div id="sim12-matrix" style="width:120px; height:280px; border:2px solid var(--accent-blue); border-radius:6px; position:relative; overflow:hidden; background:var(--bg-surface);"></div>
                        </div>
                        <div style="display:flex; flex-direction:column; align-items:center; gap:10px;">
                            <div id="sim12-token-label" style="font-family:var(--font-mono); font-size:1.2rem; color:var(--accent-amber);"></div>
                            <div style="font-size:2rem; color:var(--text-muted);">→</div>
                            <div style="display:flex; gap:5px; flex-wrap:wrap; justify-content:center;" id="sim12-btns"></div>
                        </div>
                        <div style="flex:1; display:flex; flex-direction:column; align-items:center;">
                            <div style="font-family:var(--font-mono); margin-bottom:10px; font-size:0.9rem; color:var(--text-muted);">Embedding Vector (512-dim)</div>
                            <div style="display:flex; gap:3px; align-items:flex-end; height:200px;" id="sim12-vec"></div>
                        </div>
                    </div>
                `;

                // Build buttons
                const btns = document.getElementById('sim12-btns');
                tokenData.forEach((t,i) => {
                    const b = document.createElement('button');
                    b.textContent = t.word;
                    b.style.fontSize = '0.85rem';
                    b.style.padding = '6px 12px';
                    b.onclick = () => { activeIdx = i; animate(); };
                    btns.appendChild(b);
                });

                // Build matrix heatmap
                const mat = document.getElementById('sim12-matrix');
                const rows = 30;
                for (let i = 0; i < rows; i++) {
                    const row = document.createElement('div');
                    row.style.cssText = 'display:flex; height:8px; margin:1px 2px; gap:1px;';
                    row.className = 'matrix-row';
                    for (let j = 0; j < 8; j++) {
                        const cell = document.createElement('div');
                        cell.style.cssText = `flex:1; background:hsl(${200+Math.random()*60},40%,${15+Math.random()*20}%); border-radius:1px; transition:background 0.5s;`;
                        row.appendChild(cell);
                    }
                    mat.appendChild(row);
                }

                const highlightRow = document.createElement('div');
                highlightRow.style.cssText = 'position:absolute; left:0; width:100%; height:10px; background:var(--accent-amber); opacity:0; transition:all 0.5s; border-radius:2px;';
                mat.appendChild(highlightRow);

                function animate() {
                    const t = tokenData[activeIdx];
                    document.getElementById('sim12-token-label').innerHTML = `"${t.word}" <span style="color:var(--text-muted);">(ID: ${t.id})</span>`;

                    // Highlight row in matrix
                    const rowPos = (t.id % rows) * 9.5 + 2;
                    highlightRow.style.top = rowPos + 'px';
                    highlightRow.style.opacity = '0.7';

                    // Seed random per word for consistency
                    const seed = t.id;
                    const vec = document.getElementById('sim12-vec');
                    vec.innerHTML = '';
                    for (let i = 0; i < 12; i++) {
                        const val = Math.sin(seed * (i+1) * 0.1) * 0.8;
                        const bar = document.createElement('div');
                        const absH = Math.abs(val) * 180 + 10;
                        bar.style.cssText = `width:18px; height:0px; border-radius:3px; transition:height 0.5s ease ${i*50}ms; background:${val>=0?'var(--accent-green)':'var(--accent-red)'}; opacity:0.8;`;
                        vec.appendChild(bar);
                        setTimeout(()=>{ bar.style.height = absH + 'px'; }, 50);
                    }
                }
                animate();
            },

            'sim-13': (container) => { // Positional Encoding - Enhanced
                container.innerHTML = `
                    <div style="height:100%; display:flex; flex-direction:column; padding:15px; box-sizing:border-box;">
                        <div id="sim13-viz" style="flex:1; min-height:0; position:relative;"></div>
                        <div id="sim13-tooltip" style="position:absolute; background:rgba(0,0,0,0.9); color:white; padding:8px 12px; border-radius:6px; font-family:var(--font-mono); font-size:0.8rem; pointer-events:none; display:none; z-index:10; border:1px solid var(--accent-blue);"></div>
                        <div style="text-align:center; padding:5px 0; color:var(--text-muted); font-size:0.9rem;">
                            Positional Encodings — Hover cells for details | Each position gets a unique wave pattern
                        </div>
                        <div id="sim13-waves" style="height:120px; width:100%;"></div>
                    </div>
                `;

                const vizEl = document.getElementById('sim13-viz');
                const vW = vizEl.clientWidth, vH = vizEl.clientHeight;
                const d_model = 40, seq_len = 40;
                const cellW = vW / seq_len, cellH = vH / d_model;

                const svg = d3.select("#sim13-viz").append("svg").attr("width",vW).attr("height",vH);
                const tooltip = document.getElementById('sim13-tooltip');

                // Animate heatmap building row by row
                for (let pos = 0; pos < seq_len; pos++) {
                    for (let dim = 0; dim < d_model; dim++) {
                        const val = dim % 2 === 0
                            ? Math.sin(pos / Math.pow(10000, dim / d_model))
                            : Math.cos(pos / Math.pow(10000, (dim-1) / d_model));
                        const color = d3.interpolateRdBu(0.5 - val*0.5);

                        svg.append("rect")
                            .attr("x", pos*cellW).attr("y", dim*cellH)
                            .attr("width", cellW-0.5).attr("height", cellH-0.5)
                            .attr("fill", color)
                            .attr("opacity", 0)
                            .on("mouseenter", function(e) {
                                tooltip.style.display = 'block';
                                tooltip.style.left = (e.pageX+10)+'px';
                                tooltip.style.top = (e.pageY-40)+'px';
                                const fn = dim%2===0 ? 'sin' : 'cos';
                                tooltip.textContent = `Pos:${pos} Dim:${dim} ${fn}(${pos}/10000^(${dim}/${d_model})) = ${val.toFixed(3)}`;
                            })
                            .on("mouseleave", ()=>{ tooltip.style.display='none'; })
                            .transition().duration(30).delay(pos*30)
                            .attr("opacity",1);
                    }
                }

                // Axis labels
                svg.append("text").attr("x",vW/2).attr("y",vH+12).attr("text-anchor","middle").attr("fill","var(--text-muted)").attr("font-size","10px").text("Position");
                svg.append("text").attr("x",-vH/2).attr("y",-5).attr("text-anchor","middle").attr("fill","var(--text-muted)").attr("font-size","10px").attr("transform","rotate(-90)").text("Dimension");

                // Wave visualization
                const wEl = document.getElementById('sim13-waves');
                const wW = wEl.clientWidth, wH = 120;
                const wSvg = d3.select("#sim13-waves").append("svg").attr("width",wW).attr("height",wH);
                const waveDims = [0, 4, 10, 20];
                const wColors = ["var(--accent-blue)","var(--accent-purple)","var(--accent-amber)","var(--accent-green)"];
                const wx = d3.scaleLinear().domain([0,seq_len-1]).range([30,wW-10]);
                const wy = d3.scaleLinear().domain([-1.2,1.2]).range([wH-10,5]);

                waveDims.forEach((dim,di) => {
                    const pts = d3.range(seq_len).map(pos => {
                        const val = Math.sin(pos/Math.pow(10000,dim/d_model));
                        return [wx(pos),wy(val)];
                    });
                    const line = d3.line()(pts);
                    wSvg.append("path").attr("d",line).attr("fill","none").attr("stroke",wColors[di]).attr("stroke-width",2).attr("opacity",0.7);
                    wSvg.append("text").attr("x",wW-5).attr("y",wy(Math.sin((seq_len-1)/Math.pow(10000,dim/d_model)))).attr("fill",wColors[di]).attr("font-size","9px").attr("text-anchor","end").text("d="+dim);
                });
            },

            'sim-14': (container) => { // Q K V Projection - Interactive
                container.innerHTML = `
                    <div style="height:100%; display:flex; flex-direction:column; align-items:center; justify-content:center; padding:20px;">
                        <div style="text-align:center; margin-bottom:30px;">
                            <h3 style="margin:0 0 10px 0; color:var(--accent-blue);">Query, Key, Value Projections</h3>
                            <p style="margin:0; color:var(--text-secondary); font-size:1.1rem;">Click each matrix to see the transformation</p>
                        </div>
                        <div id="sim14-viz" style="width:100%; height:70%;"></div>
                        <div id="sim14-info" style="margin-top:20px; text-align:center; color:var(--text-secondary); font-size:1.1rem; min-height:25px;"></div>
                    </div>
                `;

                const w = container.clientWidth;
                const h = container.clientHeight * 0.7;
                const svg = d3.select("#sim14-viz").append("svg").attr("width", w).attr("height", h);

                const centerY = h / 2;
                const inputX = w * 0.15;
                const matrixX = w * 0.35;
                const outputX = w * 0.7;

                // Input vector (512-dim representation)
                const inputGroup = svg.append("g").attr("class", "input-group");

                inputGroup.append("rect")
                    .attr("x", inputX - 30)
                    .attr("y", centerY - 100)
                    .attr("width", 60)
                    .attr("height", 200)
                    .attr("fill", "linear-gradient(180deg, var(--accent-code), var(--accent-purple))")
                    .attr("rx", 6)
                    .attr("stroke", "var(--accent-purple)")
                    .attr("stroke-width", 2)
                    .style("filter", "drop-shadow(0 0 10px var(--accent-purple))");

                // Add flowing particles in input
                const particleGroup = svg.append("g").attr("class", "particles");

                function createParticles() {
                    for (let i = 0; i < 8; i++) {
                        particleGroup.append("circle")
                            .attr("cx", inputX)
                            .attr("cy", centerY - 90 + i * 25)
                            .attr("r", 3)
                            .attr("fill", "white")
                            .attr("opacity", 0.8)
                            .transition()
                            .duration(2000)
                            .ease(d3.easeLinear)
                            .attr("cy", centerY + 90)
                            .attr("opacity", 0)
                            .on("end", function () {
                                d3.select(this).remove();
                            });
                    }
                }

                setInterval(createParticles, 2000);
                createParticles();

                inputGroup.append("text")
                    .text("Input")
                    .attr("x", inputX)
                    .attr("y", centerY + 120)
                    .attr("text-anchor", "middle")
                    .attr("fill", "white")
                    .attr("font-size", "1rem")
                    .attr("font-weight", "bold");

                inputGroup.append("text")
                    .text("(512-dim)")
                    .attr("x", inputX)
                    .attr("y", centerY + 140)
                    .attr("text-anchor", "middle")
                    .attr("fill", "var(--text-muted)")
                    .attr("font-size", "0.85rem");

                // Projection matrices and outputs
                const projections = [
                    { name: "Query", symbol: "Wq", color: "#ef4444", yOffset: -150 },
                    { name: "Key", symbol: "Wk", color: "#22c55e", yOffset: 0 },
                    { name: "Value", symbol: "Wv", color: "#3b82f6", yOffset: 150 }
                ];

                projections.forEach((proj, idx) => {
                    const yPos = centerY + proj.yOffset;

                    // Matrix box
                    const matrixGroup = svg.append("g")
                        .attr("class", `matrix-${idx}`)
                        .style("cursor", "pointer");

                    matrixGroup.append("rect")
                        .attr("x", matrixX - 50)
                        .attr("y", yPos - 40)
                        .attr("width", 100)
                        .attr("height", 80)
                        .attr("fill", "var(--bg-elevated)")
                        .attr("stroke", proj.color)
                        .attr("stroke-width", 2)
                        .attr("rx", 8)
                        .attr("class", `matrix-box-${idx}`)
                        .style("transition", "all 0.3s ease");

                    // Matrix grid pattern
                    for (let i = 0; i < 6; i++) {
                        for (let j = 0; j < 6; j++) {
                            matrixGroup.append("rect")
                                .attr("x", matrixX - 42 + j * 14)
                                .attr("y", yPos - 32 + i * 11)
                                .attr("width", 12)
                                .attr("height", 9)
                                .attr("fill", proj.color)
                                .attr("opacity", 0.2 + Math.random() * 0.3);
                        }
                    }

                    matrixGroup.append("text")
                        .text(proj.symbol)
                        .attr("x", matrixX)
                        .attr("y", yPos + 60)
                        .attr("text-anchor", "middle")
                        .attr("fill", proj.color)
                        .attr("font-size", "1.2rem")
                        .attr("font-weight", "bold");

                    // Output vector
                    const outputGroup = svg.append("g")
                        .attr("class", `output-${idx}`)
                        .attr("opacity", 0);

                    outputGroup.append("rect")
                        .attr("x", outputX - 25)
                        .attr("y", yPos - 30)
                        .attr("width", 50)
                        .attr("height", 60)
                        .attr("fill", proj.color)
                        .attr("rx", 6)
                        .attr("stroke", proj.color)
                        .attr("stroke-width", 2)
                        .style("filter", `drop-shadow(0 0 10px ${proj.color})`);

                    outputGroup.append("text")
                        .text(proj.name)
                        .attr("x", outputX)
                        .attr("y", yPos + 50)
                        .attr("text-anchor", "middle")
                        .attr("fill", proj.color)
                        .attr("font-size", "1rem")
                        .attr("font-weight", "bold");

                    outputGroup.append("text")
                        .text("(64-dim)")
                        .attr("x", outputX)
                        .attr("y", yPos + 68)
                        .attr("text-anchor", "middle")
                        .attr("fill", "var(--text-muted)")
                        .attr("font-size", "0.8rem");

                    // Click interaction
                    matrixGroup.on("click", function () {
                        // Reset all
                        svg.selectAll(".connection-line").remove();
                        svg.selectAll(".dot-product-particles").remove();
                        projections.forEach((_, i) => {
                            svg.select(`.output-${i}`).transition().duration(300).attr("opacity", 0);
                            svg.select(`.matrix-box-${i}`).attr("stroke-width", 2);
                        });

                        // Highlight selected matrix
                        d3.select(`.matrix-box-${idx}`)
                            .transition()
                            .duration(200)
                            .attr("stroke-width", 4)
                            .style("filter", `drop-shadow(0 0 15px ${proj.color})`);

                        // Show connection line
                        const line = svg.append("line")
                            .attr("class", "connection-line")
                            .attr("x1", inputX + 30)
                            .attr("y1", centerY)
                            .attr("x2", inputX + 30)
                            .attr("y2", centerY)
                            .attr("stroke", proj.color)
                            .attr("stroke-width", 3)
                            .attr("opacity", 0.6)
                            .style("filter", `drop-shadow(0 0 5px ${proj.color})`);

                        line.transition()
                            .duration(400)
                            .attr("x2", matrixX - 50)
                            .attr("y2", yPos);

                        // Animate dot product particles
                        setTimeout(() => {
                            for (let i = 0; i < 12; i++) {
                                svg.append("circle")
                                    .attr("class", "dot-product-particles")
                                    .attr("cx", matrixX)
                                    .attr("cy", yPos)
                                    .attr("r", 4)
                                    .attr("fill", proj.color)
                                    .attr("opacity", 0.8)
                                    .transition()
                                    .delay(i * 40)
                                    .duration(600)
                                    .ease(d3.easeCubicOut)
                                    .attr("cx", outputX)
                                    .attr("cy", yPos)
                                    .attr("opacity", 0)
                                    .remove();
                            }
                        }, 400);

                        // Show output
                        setTimeout(() => {
                            svg.select(`.output-${idx}`)
                                .transition()
                                .duration(400)
                                .attr("opacity", 1);

                            document.getElementById('sim14-info').innerHTML = `
                                <span style="color:${proj.color}; font-weight:bold;">${proj.name}</span> = 
                                Input (512-dim) × ${proj.symbol} (512×64) = 
                                <span style="color:${proj.color}; font-weight:bold;">${proj.name} Vector (64-dim)</span>
                            `;
                        }, 800);
                    });

                    // Hover effect
                    matrixGroup.on("mouseenter", function () {
                        d3.select(this).select("rect")
                            .transition()
                            .duration(200)
                            .attr("stroke-width", 3)
                            .style("filter", `drop-shadow(0 0 10px ${proj.color})`);
                    });

                    matrixGroup.on("mouseleave", function () {
                        if (d3.select(`.matrix-box-${idx}`).attr("stroke-width") != 4) {
                            d3.select(this).select("rect")
                                .transition()
                                .duration(200)
                                .attr("stroke-width", 2)
                                .style("filter", "none");
                        }
                    });
                });

                // Initial instruction
                document.getElementById('sim14-info').innerText = "Click on any matrix (Wq, Wk, or Wv) to see the projection";
            },

            'sim-15': (container) => { // Self-Attention - Enhanced
                container.innerHTML = `
                    <div style="height:100%; display:flex; flex-direction:column;">
                        <div style="text-align:center; padding:10px; color:var(--text-secondary); font-size:1.2rem;">
                            Click any word to see its attention pattern
                        </div>
                        <div style="display:flex; justify-content:space-around; padding:20px; flex-wrap:wrap; gap:15px;" id="sim15-tokens">
                            <div class="attn-token" data-id="0" style="padding:12px 20px; border:2px solid var(--text-primary); cursor:pointer; border-radius:8px; font-size:1.3rem; transition:all 0.3s ease; background:var(--glass-surface);">The</div>
                            <div class="attn-token" data-id="1" style="padding:12px 20px; border:2px solid var(--text-primary); cursor:pointer; border-radius:8px; font-size:1.3rem; transition:all 0.3s ease; background:var(--glass-surface);">animal</div>
                            <div class="attn-token" data-id="2" style="padding:12px 20px; border:2px solid var(--text-primary); cursor:pointer; border-radius:8px; font-size:1.3rem; transition:all 0.3s ease; background:var(--glass-surface);">didn't</div>
                            <div class="attn-token" data-id="3" style="padding:12px 20px; border:2px solid var(--text-primary); cursor:pointer; border-radius:8px; font-size:1.3rem; transition:all 0.3s ease; background:var(--glass-surface);">cross</div>
                            <div class="attn-token" data-id="4" style="padding:12px 20px; border:2px solid var(--text-primary); cursor:pointer; border-radius:8px; font-size:1.3rem; transition:all 0.3s ease; background:var(--glass-surface);">the</div>
                            <div class="attn-token" data-id="5" style="padding:12px 20px; border:2px solid var(--text-primary); cursor:pointer; border-radius:8px; font-size:1.3rem; transition:all 0.3s ease; background:var(--glass-surface);">street</div>
                            <div class="attn-token" data-id="6" style="padding:12px 20px; border:2px solid var(--text-primary); cursor:pointer; border-radius:8px; font-size:1.3rem; transition:all 0.3s ease; background:var(--glass-surface);">because</div>
                            <div class="attn-token" data-id="7" style="padding:12px 20px; border:2px solid var(--text-primary); cursor:pointer; border-radius:8px; font-size:1.3rem; transition:all 0.3s ease; background:var(--glass-surface);">it</div>
                            <div class="attn-token" data-id="8" style="padding:12px 20px; border:2px solid var(--text-primary); cursor:pointer; border-radius:8px; font-size:1.3rem; transition:all 0.3s ease; background:var(--glass-surface);">was</div>
                            <div class="attn-token" data-id="9" style="padding:12px 20px; border:2px solid var(--text-primary); cursor:pointer; border-radius:8px; font-size:1.3rem; transition:all 0.3s ease; background:var(--glass-surface);">too</div>
                            <div class="attn-token" data-id="10" style="padding:12px 20px; border:2px solid var(--text-primary); cursor:pointer; border-radius:8px; font-size:1.3rem; transition:all 0.3s ease; background:var(--glass-surface);">tired</div>
                        </div>
                        <div id="sim15-viz" style="flex:1; width:100%; position:relative;"></div>
                    </div>
                 `;

                const w = container.clientWidth;
                const h = container.clientHeight * 0.6;
                const svg = d3.select("#sim15-viz").append("svg").attr("width", w).attr("height", h);

                const tokens = ["The", "animal", "didn't", "cross", "the", "street", "because", "it", "was", "too", "tired"];
                const numTokens = tokens.length;
                const x = d3.scalePoint().domain(d3.range(numTokens)).range([w * 0.05, w * 0.95]);

                // Realistic Attention Matrix
                const attn = [
                    [0.70, 0.15, 0.05, 0.02, 0.02, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01], // The
                    [0.10, 0.60, 0.10, 0.05, 0.03, 0.03, 0.03, 0.03, 0.01, 0.01, 0.01], // animal
                    [0.05, 0.20, 0.50, 0.15, 0.03, 0.02, 0.02, 0.01, 0.01, 0.01, 0.00], // didn't
                    [0.02, 0.10, 0.25, 0.45, 0.05, 0.08, 0.02, 0.01, 0.01, 0.01, 0.00], // cross
                    [0.03, 0.05, 0.03, 0.10, 0.60, 0.15, 0.02, 0.01, 0.01, 0.00, 0.00], // the
                    [0.01, 0.05, 0.05, 0.15, 0.15, 0.50, 0.05, 0.02, 0.01, 0.01, 0.00], // street
                    [0.01, 0.03, 0.10, 0.05, 0.02, 0.05, 0.60, 0.08, 0.03, 0.02, 0.01], // because
                    [0.02, 0.45, 0.05, 0.03, 0.02, 0.05, 0.08, 0.15, 0.05, 0.03, 0.07], // it (attends to "animal" and "tired")
                    [0.01, 0.03, 0.05, 0.02, 0.01, 0.02, 0.10, 0.15, 0.50, 0.08, 0.03], // was
                    [0.01, 0.02, 0.02, 0.01, 0.01, 0.01, 0.05, 0.05, 0.10, 0.60, 0.12], // too
                    [0.01, 0.08, 0.02, 0.01, 0.01, 0.01, 0.03, 0.10, 0.05, 0.15, 0.53]  // tired
                ];

                // Color scale from blue (low) to amber (high)
                const colorScale = d3.scaleLinear()
                    .domain([0, 0.5, 1])
                    .range(["#38bdf8", "#fbbf24", "#f59e0b"]);

                // Create groups for paths and labels
                const pathsGroup = svg.append("g").attr("class", "paths-group");
                const labelsGroup = svg.append("g").attr("class", "labels-group");

                const update = (selectedIdx) => {
                    // Smooth transition duration
                    const t = d3.transition().duration(300).ease(d3.easeCubicInOut);

                    // Remove old paths and labels
                    pathsGroup.selectAll("*").transition(t).attr("opacity", 0).remove();
                    labelsGroup.selectAll("*").transition(t).attr("opacity", 0).remove();

                    // Get actual positions of word tokens from DOM
                    const tokenElements = document.querySelectorAll('.attn-token');
                    const tokenPositions = Array.from(tokenElements).map(el => {
                        const rect = el.getBoundingClientRect();
                        const svgRect = svg.node().getBoundingClientRect();
                        return {
                            x: rect.left + rect.width / 2 - svgRect.left,
                            y: rect.top + rect.height - svgRect.top + 10 // Bottom of token + 10px gap
                        };
                    });

                    // Draw curved Bézier arcs for attention
                    tokens.forEach((token, i) => {
                        const weight = attn[selectedIdx][i];

                        if (weight > 0.01) {
                            const startX = tokenPositions[selectedIdx].x;
                            const endX = tokenPositions[i].x;
                            const startY = tokenPositions[selectedIdx].y;
                            const endY = tokenPositions[i].y;

                            // Control point for Bézier curve (higher arc for longer distances)
                            const distance = Math.abs(endX - startX);
                            const arcHeight = 100 + (distance / w) * 80; // Adjusted for better visibility
                            const controlX = (startX + endX) / 2;
                            const controlY = Math.max(startY, endY) + arcHeight;

                            // Create curved path
                            const path = pathsGroup.append("path")
                                .attr("d", `M${startX},${startY} Q${controlX},${controlY} ${endX},${endY}`)
                                .attr("fill", "none")
                                .attr("stroke", colorScale(weight))
                                .attr("stroke-width", Math.max(2, weight * 15))
                                .attr("opacity", 0)
                                .attr("stroke-linecap", "round")
                                .style("filter", `drop-shadow(0 0 ${weight * 10}px ${colorScale(weight)})`);

                            // Animate path appearance
                            path.transition(t).attr("opacity", Math.max(0.4, weight));

                            // Add percentage label on arc (only for significant weights)
                            if (weight > 0.05) {
                                const labelX = controlX;
                                const labelY = controlY + 20;

                                const label = labelsGroup.append("text")
                                    .text((weight * 100).toFixed(0) + "%")
                                    .attr("x", labelX)
                                    .attr("y", labelY)
                                    .attr("text-anchor", "middle")
                                    .attr("fill", colorScale(weight))
                                    .attr("font-size", "1.1rem")
                                    .attr("font-weight", "bold")
                                    .attr("opacity", 0)
                                    .style("text-shadow", `0 0 10px ${colorScale(weight)}`);

                                label.transition(t).delay(100).attr("opacity", 1);
                            }
                        }
                    });

                    // Update token styling
                    document.querySelectorAll('.attn-token').forEach((el, i) => {
                        const isSelected = i === selectedIdx;
                        const weight = attn[selectedIdx][i];

                        if (isSelected) {
                            el.style.borderColor = "var(--accent-amber)";
                            el.style.color = "var(--accent-amber)";
                            el.style.background = "rgba(251, 191, 36, 0.2)";
                            el.style.transform = "scale(1.1)";
                            el.style.boxShadow = "0 0 20px rgba(251, 191, 36, 0.5)";
                        } else if (weight > 0.1) {
                            // Highlight strongly attended tokens
                            el.style.borderColor = colorScale(weight);
                            el.style.color = colorScale(weight);
                            el.style.background = `rgba(251, 191, 36, ${weight * 0.3})`;
                            el.style.transform = "scale(1.05)";
                            el.style.boxShadow = `0 0 10px ${colorScale(weight)}`;
                        } else {
                            el.style.borderColor = "var(--text-primary)";
                            el.style.color = "var(--text-primary)";
                            el.style.background = "var(--glass-surface)";
                            el.style.transform = "scale(1)";
                            el.style.boxShadow = "none";
                        }
                    });
                };

                // Add hover effects
                document.querySelectorAll('.attn-token').forEach(el => {
                    el.onclick = () => update(parseInt(el.dataset.id));
                    el.onmouseenter = () => {
                        if (!el.style.transform.includes("1.1")) {
                            el.style.transform = "scale(1.05)";
                        }
                    };
                    el.onmouseleave = () => {
                        const idx = parseInt(el.dataset.id);
                        const currentSelection = Array.from(document.querySelectorAll('.attn-token'))
                            .findIndex(e => e.style.borderColor.includes("251, 191, 36"));

                        if (idx !== currentSelection && attn[currentSelection]?.[idx] <= 0.1) {
                            el.style.transform = "scale(1)";
                        }
                    };
                });

                // Start with "it" selected to show pronoun resolution
                update(7);
            },

            'sim-16': (container) => { // Multi-Head Attention - Enhanced
                container.innerHTML = `
                    <div style="height:100%; display:flex; flex-direction:column; align-items:center; justify-content:center; padding:20px;">
                        <div style="text-align:center; margin-bottom:20px;">
                            <h3 style="margin:0 0 10px 0; color:var(--accent-blue);">Multi-Head Attention (8 Heads)</h3>
                            <p style="margin:0; color:var(--text-secondary); font-size:1.1rem;">Each head learns different patterns in parallel</p>
                        </div>
                        <button id="sim16-btn" style="padding:12px 30px; background:linear-gradient(135deg, var(--accent-blue), var(--accent-purple)); border:none; border-radius:8px; font-weight:bold; cursor:pointer; margin-bottom:30px; font-size:1.1rem; color:white; box-shadow:0 4px 15px rgba(56, 189, 248, 0.3); transition:all 0.3s ease;">
                            ▶ Run Multi-Head Attention
                        </button>
                        <div id="sim16-viz" style="width:100%; height:60%;"></div>
                        <div id="sim16-desc" style="margin-top:25px; color:var(--text-secondary); font-size:1.2rem; text-align:center; min-height:30px; font-weight:600;"></div>
                    </div>
                `;

                const w = container.clientWidth;
                const h = container.clientHeight * 0.6;
                const svg = d3.select("#sim16-viz").append("svg").attr("width", w).attr("height", h);

                const heads = 8;
                const headW = (w * 0.8) / heads;
                const startX = w * 0.1;

                // Head colors and labels
                const headInfo = [
                    { color: "#ef4444", label: "Grammar" },
                    { color: "#f59e0b", label: "Pronouns" },
                    { color: "#eab308", label: "Local Context" },
                    { color: "#22c55e", label: "Syntax" },
                    { color: "#06b6d4", label: "Semantics" },
                    { color: "#3b82f6", label: "Position" },
                    { color: "#8b5cf6", label: "Entities" },
                    { color: "#ec4899", label: "Relations" }
                ];

                // Input box
                const inputBox = svg.append("rect")
                    .attr("x", w / 2 - 60)
                    .attr("y", h - 40)
                    .attr("width", 120)
                    .attr("height", 35)
                    .attr("fill", "var(--accent-blue)")
                    .attr("rx", 6)
                    .attr("stroke", "var(--accent-purple)")
                    .attr("stroke-width", 2)
                    .style("filter", "drop-shadow(0 0 10px var(--accent-blue))");

                svg.append("text")
                    .text("Input Vector")
                    .attr("x", w / 2)
                    .attr("y", h - 17)
                    .attr("text-anchor", "middle")
                    .attr("fill", "white")
                    .attr("font-size", "0.9rem")
                    .attr("font-weight", "bold");

                // Create head boxes
                const headGroup = svg.selectAll(".head").data(d3.range(heads)).enter().append("g")
                    .attr("class", "head");

                headGroup.append("rect")
                    .attr("x", (d, i) => startX + i * headW + headW * 0.1)
                    .attr("y", h / 2 - 35)
                    .attr("width", headW * 0.8)
                    .attr("height", 70)
                    .attr("fill", "var(--bg-elevated)")
                    .attr("stroke", (d, i) => headInfo[i].color)
                    .attr("stroke-width", 2)
                    .attr("rx", 8)
                    .attr("class", "head-box");

                headGroup.append("text")
                    .text((d, i) => `H${i + 1}`)
                    .attr("x", (d, i) => startX + i * headW + headW * 0.5)
                    .attr("y", h / 2 - 5)
                    .attr("text-anchor", "middle")
                    .attr("fill", "white")
                    .attr("font-size", "1.1rem")
                    .attr("font-weight", "bold");

                headGroup.append("text")
                    .text((d, i) => headInfo[i].label)
                    .attr("x", (d, i) => startX + i * headW + headW * 0.5)
                    .attr("y", h / 2 + 15)
                    .attr("text-anchor", "middle")
                    .attr("fill", (d, i) => headInfo[i].color)
                    .attr("font-size", "0.75rem")
                    .attr("class", "head-label");

                // Output box (wider to fit text)
                const outputBox = svg.append("rect")
                    .attr("x", w / 2 - 80)
                    .attr("y", 20)
                    .attr("width", 160)
                    .attr("height", 35)
                    .attr("fill", "var(--accent-green)")
                    .attr("rx", 6)
                    .attr("opacity", 0)
                    .attr("stroke", "var(--accent-amber)")
                    .attr("stroke-width", 2)
                    .style("filter", "drop-shadow(0 0 10px var(--accent-green))");

                svg.append("text")
                    .text("Concatenated Output")
                    .attr("x", w / 2)
                    .attr("y", 43)
                    .attr("text-anchor", "middle")
                    .attr("fill", "white")
                    .attr("font-size", "0.8rem")
                    .attr("font-weight", "bold")
                    .attr("opacity", 0)
                    .attr("id", "output-label");

                // Animation function
                document.getElementById('sim16-btn').onclick = () => {
                    // Reset
                    svg.selectAll(".split-line").remove();
                    svg.selectAll(".merge-line").remove();
                    outputBox.attr("opacity", 0);
                    d3.select("#output-label").attr("opacity", 0);
                    document.getElementById('sim16-desc').innerText = "";

                    // Phase 1: Split input to heads (staggered)
                    document.getElementById('sim16-desc').innerText = "Splitting input into 8 parallel streams...";

                    d3.range(heads).forEach((d, i) => {
                        setTimeout(() => {
                            svg.append("line")
                                .attr("class", "split-line")
                                .attr("x1", w / 2)
                                .attr("y1", h - 40)
                                .attr("x2", w / 2)
                                .attr("y2", h - 40)
                                .attr("stroke", headInfo[i].color)
                                .attr("stroke-width", 3)
                                .attr("opacity", 0.8)
                                .style("filter", `drop-shadow(0 0 5px ${headInfo[i].color})`)
                                .transition()
                                .duration(400)
                                .ease(d3.easeCubicOut)
                                .attr("x2", startX + i * headW + headW * 0.5)
                                .attr("y2", h / 2 + 35);
                        }, i * 100);
                    });

                    // Phase 2: Process in each head (staggered pulses)
                    setTimeout(() => {
                        document.getElementById('sim16-desc').innerText = "Processing in parallel: Grammar, Pronouns, Context, Syntax...";

                        d3.range(heads).forEach((d, i) => {
                            setTimeout(() => {
                                // Pulse animation
                                d3.selectAll(".head-box")
                                    .filter((_, idx) => idx === i)
                                    .transition()
                                    .duration(200)
                                    .attr("fill", headInfo[i].color)
                                    .attr("stroke-width", 4)
                                    .style("filter", `drop-shadow(0 0 15px ${headInfo[i].color})`)
                                    .transition()
                                    .duration(300)
                                    .attr("fill", "var(--bg-elevated)")
                                    .attr("stroke-width", 2)
                                    .style("filter", "none");

                                // Brighten label
                                d3.selectAll(".head-label")
                                    .filter((_, idx) => idx === i)
                                    .transition()
                                    .duration(200)
                                    .attr("font-size", "0.85rem")
                                    .attr("font-weight", "bold")
                                    .transition()
                                    .duration(300)
                                    .attr("font-size", "0.75rem")
                                    .attr("font-weight", "normal");
                            }, i * 100);
                        });
                    }, 1000);

                    // Phase 3: Merge outputs (staggered)
                    setTimeout(() => {
                        document.getElementById('sim16-desc').innerText = "Concatenating outputs from all heads...";

                        d3.range(heads).forEach((d, i) => {
                            setTimeout(() => {
                                svg.append("line")
                                    .attr("class", "merge-line")
                                    .attr("x1", startX + i * headW + headW * 0.5)
                                    .attr("y1", h / 2 - 35)
                                    .attr("x2", startX + i * headW + headW * 0.5)
                                    .attr("y2", h / 2 - 35)
                                    .attr("stroke", headInfo[i].color)
                                    .attr("stroke-width", 3)
                                    .attr("opacity", 0.8)
                                    .style("filter", `drop-shadow(0 0 5px ${headInfo[i].color})`)
                                    .transition()
                                    .duration(500)
                                    .ease(d3.easeCubicIn)
                                    .attr("x2", w / 2)
                                    .attr("y2", 55);
                            }, i * 80);
                        });
                    }, 2200);

                    // Phase 4: Show output
                    setTimeout(() => {
                        outputBox.transition()
                            .duration(400)
                            .attr("opacity", 1);

                        d3.select("#output-label").transition()
                            .duration(400)
                            .attr("opacity", 1);

                        document.getElementById('sim16-desc').innerText = "✓ Multi-head attention complete! Each head captured different patterns.";
                        document.getElementById('sim16-desc').style.color = "var(--accent-green)";
                    }, 3000);

                    // Reset description color
                    setTimeout(() => {
                        document.getElementById('sim16-desc').style.color = "var(--text-secondary)";
                    }, 5000);
                };

                // Hover effect on button
                const btn = document.getElementById('sim16-btn');
                btn.onmouseenter = () => {
                    btn.style.transform = "translateY(-2px)";
                    btn.style.boxShadow = "0 6px 20px rgba(56, 189, 248, 0.5)";
                };
                btn.onmouseleave = () => {
                    btn.style.transform = "translateY(0)";
                    btn.style.boxShadow = "0 4px 15px rgba(56, 189, 248, 0.3)";
                };
            },

            'sim-17': (container) => { // Feed Forward - Enhanced
                container.innerHTML = `
                    <div style="height:100%; display:flex; flex-direction:column; align-items:center; justify-content:center; padding:20px; box-sizing:border-box;">
                        <div id="sim17-viz" style="width:100%; flex:1; min-height:0;"></div>
                        <div style="display:flex; gap:15px; align-items:center; margin-top:10px;">
                            <button id="sim17-btn">Process</button>
                            <div id="sim17-status" style="font-family:var(--font-mono); color:var(--text-secondary); font-size:0.95rem; min-width:300px;"></div>
                        </div>
                        <div style="margin-top:10px; text-align:center; color:var(--text-muted); font-size:0.9rem;">Attention = Communication between tokens. FFN = Individual computation per token.</div>
                    </div>
                `;

                const w = container.clientWidth, h = container.clientHeight*0.65;
                const svg = d3.select("#sim17-viz").append("svg").attr("width",w).attr("height",h);
                const defs = svg.append("defs");
                defs.append("marker").attr("id","ffnArr").attr("viewBox","0 -5 10 10").attr("refX",10).attr("refY",0).attr("markerWidth",8).attr("markerHeight",8).attr("orient","auto")
                    .append("path").attr("d","M0,-5L10,0L0,5").attr("fill","white");

                const blocks = [
                    {x:w*0.08, bw:w*0.18, y:h*0.35, bh:h*0.3, label:"512 dim", color:"var(--accent-blue)"},
                    {x:w*0.38, bw:w*0.24, y:h*0.05, bh:h*0.9, label:"2048 dim", color:"var(--accent-amber)"},
                    {x:w*0.74, bw:w*0.18, y:h*0.35, bh:h*0.3, label:"512 dim", color:"var(--accent-green)"}
                ];

                blocks.forEach(b=>{
                    svg.append("rect").attr("x",b.x).attr("y",b.y).attr("width",b.bw).attr("height",b.bh).attr("fill",b.color).attr("rx",8).attr("opacity",0.3).attr("class","ffn-block");
                    svg.append("rect").attr("x",b.x).attr("y",b.y).attr("width",b.bw).attr("height",b.bh).attr("fill","none").attr("stroke",b.color).attr("stroke-width",2).attr("rx",8);
                    svg.append("text").text(b.label).attr("x",b.x+b.bw/2).attr("y",b.y+b.bh/2+5).attr("text-anchor","middle").attr("fill","white").attr("font-weight","bold").attr("font-size","1rem");
                });

                // Arrows
                svg.append("line").attr("x1",blocks[0].x+blocks[0].bw+5).attr("y1",h/2).attr("x2",blocks[1].x-5).attr("y2",h/2).attr("stroke","white").attr("stroke-width",3).attr("marker-end","url(#ffnArr)");
                svg.append("line").attr("x1",blocks[1].x+blocks[1].bw+5).attr("y1",h/2).attr("x2",blocks[2].x-5).attr("y2",h/2).attr("stroke","white").attr("stroke-width",3).attr("marker-end","url(#ffnArr)");

                // ReLU graph
                const reluG = svg.append("g").attr("transform",`translate(${blocks[1].x+blocks[1].bw/2-30},${blocks[1].y+blocks[1].bh-50})`);
                reluG.append("rect").attr("width",60).attr("height",40).attr("fill","rgba(0,0,0,0.5)").attr("rx",4);
                reluG.append("line").attr("x1",5).attr("y1",35).attr("x2",30).attr("y2",35).attr("stroke","var(--accent-red)").attr("stroke-width",2);
                reluG.append("line").attr("x1",30).attr("y1",35).attr("x2",55).attr("y2",8).attr("stroke","var(--accent-green)").attr("stroke-width",2);
                reluG.append("text").text("ReLU").attr("x",30).attr("y",12).attr("text-anchor","middle").attr("fill","white").attr("font-size","8px");

                const pulse = svg.append("circle").attr("r",8).attr("fill","white").attr("opacity",0);

                document.getElementById('sim17-btn').onclick = () => {
                    const st = document.getElementById('sim17-status');
                    pulse.attr("cx",blocks[0].x+blocks[0].bw/2).attr("cy",h/2).attr("opacity",0.8);
                    st.textContent = "Input signal (512-dim) entering...";
                    st.style.color = "var(--accent-blue)";

                    pulse.transition().duration(600).attr("cx",blocks[1].x+20).on("end",()=>{
                        st.textContent = "Expanding to 2048 dimensions...";
                        st.style.color = "var(--accent-amber)";
                    }).transition().duration(800).attr("cy",h*0.3).transition().duration(400).attr("cy",h*0.5).on("end",()=>{
                        st.textContent = "ReLU: max(0, x) — removing negative activations";
                        st.style.color = "var(--accent-green)";
                    }).transition().duration(600).attr("cx",blocks[2].x+blocks[2].bw/2).on("end",()=>{
                        st.textContent = "Compressed back to 512 dimensions. Done!";
                        st.style.color = "var(--accent-green)";
                        pulse.transition().duration(500).attr("opacity",0);
                    });
                };
            },

            'sim-18': (container) => { // Residuals & LayerNorm - Enhanced
                container.innerHTML = `
                    <div style="height:100%; display:flex; flex-direction:column; padding:20px; box-sizing:border-box;">
                        <div id="sim18-viz" style="flex:1; min-height:0;"></div>
                        <div id="sim18-stage" style="text-align:center; font-family:var(--font-mono); color:var(--text-secondary); min-height:25px; font-size:0.95rem; padding:5px;"></div>
                        <div style="text-align:center; padding:5px;">
                            <button id="sim18-btn">Animate Flow</button>
                        </div>
                        <div style="text-align:center; color:var(--text-muted); font-size:0.85rem;">Without residuals: gradient decays through 96 layers. With residuals: gradient flows directly through the skip connection.</div>
                    </div>
                `;

                const w = container.clientWidth, h = container.clientHeight*0.6;
                const svg = d3.select("#sim18-viz").append("svg").attr("width",w).attr("height",h);

                const cx = w/2, bw = w*0.25, bh = h*0.25;
                const inputX = w*0.08, outputX = w*0.92;
                const mainY = h*0.55, skipY = h*0.15;

                // Processing block
                svg.append("rect").attr("x",cx-bw/2).attr("y",mainY-bh/2).attr("width",bw).attr("height",bh)
                    .attr("fill","var(--bg-elevated)").attr("stroke","var(--accent-blue)").attr("stroke-width",2).attr("rx",10);
                svg.append("text").text("Processing Layer").attr("x",cx).attr("y",mainY+5).attr("text-anchor","middle").attr("fill","white").attr("font-size","0.95rem");

                // Main path through block
                svg.append("line").attr("x1",inputX).attr("y1",mainY).attr("x2",cx-bw/2-5).attr("y2",mainY).attr("stroke","var(--accent-blue)").attr("stroke-width",2);
                svg.append("line").attr("x1",cx+bw/2+5).attr("y1",mainY).attr("x2",w*0.75).attr("y2",mainY).attr("stroke","var(--accent-blue)").attr("stroke-width",2);

                // Skip connection path
                const skipD = `M${inputX},${mainY} L${inputX+30},${mainY} L${inputX+30},${skipY} L${w*0.75},${skipY} L${w*0.75},${mainY}`;
                svg.append("path").attr("d",skipD).attr("fill","none").attr("stroke","var(--accent-green)").attr("stroke-width",3).attr("stroke-dasharray","8,4").attr("opacity",0.6);
                svg.append("text").text("Skip Connection (Residual)").attr("x",cx).attr("y",skipY-8).attr("text-anchor","middle").attr("fill","var(--accent-green)").attr("font-size","0.85rem");

                // Addition node
                svg.append("circle").attr("cx",w*0.75).attr("cy",mainY).attr("r",18).attr("fill","var(--bg-surface)").attr("stroke","white").attr("stroke-width",2);
                svg.append("text").text("+").attr("x",w*0.75).attr("y",mainY+6).attr("text-anchor","middle").attr("fill","white").attr("font-size","20px");

                // LayerNorm box
                svg.append("rect").attr("x",w*0.8).attr("y",mainY-18).attr("width",w*0.1).attr("height",36).attr("fill","var(--bg-elevated)").attr("stroke","var(--accent-purple)").attr("stroke-width",2).attr("rx",6);
                svg.append("text").text("LN").attr("x",w*0.85).attr("y",mainY+5).attr("text-anchor","middle").attr("fill","var(--accent-purple)").attr("font-weight","bold").attr("font-size","0.9rem");
                svg.append("line").attr("x1",w*0.75+18).attr("y1",mainY).attr("x2",w*0.8).attr("y2",mainY).attr("stroke","white").attr("stroke-width",2);
                svg.append("line").attr("x1",w*0.9).attr("y1",mainY).attr("x2",outputX).attr("y2",mainY).attr("stroke","white").attr("stroke-width",2);

                // Value labels
                const inputVals = [1.0,0.5,-0.3,0.8];
                const processedVals = [0.02,-0.01,0.005,-0.03];
                const addedVals = inputVals.map((v,i)=>v+processedVals[i]);
                const mean = addedVals.reduce((a,b)=>a+b)/addedVals.length;
                const std = Math.sqrt(addedVals.map(v=>(v-mean)**2).reduce((a,b)=>a+b)/addedVals.length)||1;
                const normedVals = addedVals.map(v=>((v-mean)/std));

                const valLabel = (x,y,vals,id) => {
                    svg.append("text").attr("x",x).attr("y",y).attr("text-anchor","middle").attr("fill","var(--text-muted)").attr("font-size","9px").attr("font-family","var(--font-mono)").attr("id",id)
                        .text("["+vals.map(v=>v.toFixed(2)).join(", ")+"]");
                };
                valLabel(inputX+15,mainY+35,inputVals,"v-in");
                valLabel(cx,mainY+bh/2+20,processedVals,"v-proc");

                // Animated pulses
                const mainPulse = svg.append("circle").attr("r",6).attr("fill","var(--accent-blue)").attr("opacity",0);
                const skipPulse = svg.append("circle").attr("r",6).attr("fill","var(--accent-green)").attr("opacity",0);

                document.getElementById('sim18-btn').onclick = () => {
                    const stage = document.getElementById('sim18-stage');
                    // Main path pulse
                    mainPulse.attr("cx",inputX).attr("cy",mainY).attr("opacity",0.9);
                    skipPulse.attr("cx",inputX).attr("cy",mainY).attr("opacity",0.9);

                    stage.textContent = "Input signal splits into main path and skip connection...";
                    stage.style.color = "var(--accent-blue)";

                    // Skip path animation
                    skipPulse.transition().duration(300).attr("cx",inputX+30)
                        .transition().duration(400).attr("cy",skipY)
                        .transition().duration(800).attr("cx",w*0.75)
                        .transition().duration(300).attr("cy",mainY);

                    // Main path animation
                    mainPulse.transition().duration(500).attr("cx",cx-bw/2).on("end",()=>{
                        stage.textContent = "Processing layer transforms signal (but may diminish it)...";
                    }).transition().duration(800).attr("cx",cx+bw/2).on("end",()=>{
                        stage.textContent = "Addition: Original + Processed = Signal preserved!";
                        stage.style.color = "var(--accent-green)";
                    }).transition().duration(400).attr("cx",w*0.75).on("end",()=>{
                        mainPulse.transition().duration(200).attr("opacity",0);
                        skipPulse.transition().duration(200).attr("opacity",0);
                    }).transition().delay(300).duration(1).on("end",()=>{
                        stage.textContent = "LayerNorm: Normalize to mean=0, std=1. Stable gradients!";
                        stage.style.color = "var(--accent-purple)";
                    });
                };
            },

            'sim-19': (container) => { // Transformer Block - Full SVG Flow Diagram
                container.innerHTML = `
                    <div style="height:100%; display:flex; flex-direction:column; align-items:center; padding:15px; box-sizing:border-box;">
                        <div style="display:flex; gap:20px; align-items:center; margin-bottom:8px;">
                            <h3 style="margin:0; color:var(--accent-blue); font-size:1.4rem;">One Transformer Block</h3>
                            <button id="sim19-trace" style="padding:8px 22px; background:linear-gradient(135deg, var(--accent-blue), var(--accent-purple)); border:none; border-radius:8px; font-weight:bold; cursor:pointer; font-size:0.9rem; color:white; box-shadow:0 4px 15px rgba(56,189,248,0.3);">▶ Trace Data</button>
                            <span style="color:var(--text-muted); font-size:0.85rem; background:var(--bg-elevated); padding:4px 12px; border-radius:6px; border:1px solid var(--border-subtle);">×N blocks stacked</span>
                        </div>
                        <div id="sim19-svg-wrap" style="flex:1; width:100%; min-height:0;"></div>
                        <div id="sim19-status" style="color:var(--text-secondary); font-size:1rem; min-height:22px; font-weight:600; text-align:center;"></div>
                    </div>
                `;

                requestAnimationFrame(() => { requestAnimationFrame(() => {
                    const wrap = document.getElementById('sim19-svg-wrap');
                    const w = wrap.clientWidth || 700;
                    const h = wrap.clientHeight || 420;
                    const svg = d3.select(wrap).append('svg').attr('width', w).attr('height', h);

                    const defs = svg.append('defs');
                    const glow = defs.append('filter').attr('id','s19-glow').attr('x','-50%').attr('y','-50%').attr('width','200%').attr('height','200%');
                    glow.append('feGaussianBlur').attr('stdDeviation','5').attr('result','blur');
                    const mg = glow.append('feMerge');
                    mg.append('feMergeNode').attr('in','blur');
                    mg.append('feMergeNode').attr('in','SourceGraphic');

                    // Vertical flow layout
                    const cx = w * 0.45;
                    const boxW = 200, boxH = 42;
                    const stages = [
                        { label: 'Input Embedding', color: '#6366f1', y: h*0.06 },
                        { label: 'Multi-Head Attention', color: '#3b82f6', y: h*0.22 },
                        { label: 'Add & LayerNorm', color: '#8b5cf6', y: h*0.38, isNorm: true },
                        { label: 'Feed-Forward Network', color: '#f59e0b', y: h*0.54 },
                        { label: 'Add & LayerNorm', color: '#10b981', y: h*0.70, isNorm: true },
                        { label: 'Output', color: '#22d3ee', y: h*0.88 }
                    ];

                    // Draw main vertical path
                    stages.forEach((s, i) => {
                        if (i < stages.length - 1) {
                            svg.append('line')
                                .attr('x1', cx).attr('y1', s.y + boxH/2 + 4)
                                .attr('x2', cx).attr('y2', stages[i+1].y - boxH/2 - 4)
                                .attr('stroke', 'var(--text-muted)').attr('stroke-width', 2)
                                .attr('opacity', 0.3).attr('marker-end', 'none');
                            // Arrow head
                            svg.append('polygon')
                                .attr('points', `${cx-5},${stages[i+1].y - boxH/2 - 6} ${cx+5},${stages[i+1].y - boxH/2 - 6} ${cx},${stages[i+1].y - boxH/2 - 1}`)
                                .attr('fill', 'var(--text-muted)').attr('opacity', 0.4);
                        }
                    });

                    // Skip connections (curved paths on the right)
                    // Skip 1: Input -> Add&Norm1 (around MHA)
                    const skipX = cx + boxW/2 + 40;
                    const skip1 = svg.append('path')
                        .attr('d', `M${cx + boxW/2},${stages[0].y} C${skipX+20},${stages[0].y} ${skipX+20},${stages[2].y} ${cx + boxW/2},${stages[2].y}`)
                        .attr('fill', 'none').attr('stroke', '#8b5cf6').attr('stroke-width', 2)
                        .attr('stroke-dasharray', '6,4').attr('opacity', 0.4);
                    svg.append('text').attr('x', skipX + 10).attr('y', (stages[0].y + stages[2].y)/2 + 4)
                        .attr('fill', '#8b5cf6').attr('font-size', '0.7rem').attr('opacity', 0.6).text('residual');

                    // Skip 2: Add&Norm1 -> Add&Norm2 (around FFN)
                    const skip2 = svg.append('path')
                        .attr('d', `M${cx + boxW/2},${stages[2].y} C${skipX+20},${stages[2].y} ${skipX+20},${stages[4].y} ${cx + boxW/2},${stages[4].y}`)
                        .attr('fill', 'none').attr('stroke', '#10b981').attr('stroke-width', 2)
                        .attr('stroke-dasharray', '6,4').attr('opacity', 0.4);
                    svg.append('text').attr('x', skipX + 10).attr('y', (stages[2].y + stages[4].y)/2 + 4)
                        .attr('fill', '#10b981').attr('font-size', '0.7rem').attr('opacity', 0.6).text('residual');

                    // Draw boxes
                    const boxes = stages.map((s, i) => {
                        const g = svg.append('g');
                        const rect = g.append('rect')
                            .attr('x', cx - boxW/2).attr('y', s.y - boxH/2)
                            .attr('width', boxW).attr('height', boxH)
                            .attr('rx', s.isNorm ? 8 : 10)
                            .attr('fill', s.isNorm ? 'var(--bg-elevated)' : s.color)
                            .attr('stroke', s.color).attr('stroke-width', s.isNorm ? 2 : 0)
                            .attr('opacity', 0.9);
                        g.append('text')
                            .attr('x', cx).attr('y', s.y + 5)
                            .attr('text-anchor', 'middle')
                            .attr('fill', s.isNorm ? s.color : 'white')
                            .attr('font-size', '0.9rem').attr('font-weight', 'bold')
                            .text(s.label);
                        return { g, rect, ...s };
                    });

                    // ×N indicator
                    const bracketX = cx - boxW/2 - 30;
                    svg.append('line').attr('x1', bracketX).attr('y1', stages[1].y - boxH/2 - 5)
                        .attr('x2', bracketX).attr('y2', stages[4].y + boxH/2 + 5)
                        .attr('stroke', 'var(--accent-pink)').attr('stroke-width', 2).attr('opacity', 0.6);
                    svg.append('line').attr('x1', bracketX).attr('y1', stages[1].y - boxH/2 - 5)
                        .attr('x2', bracketX + 8).attr('y2', stages[1].y - boxH/2 - 5)
                        .attr('stroke', 'var(--accent-pink)').attr('stroke-width', 2).attr('opacity', 0.6);
                    svg.append('line').attr('x1', bracketX).attr('y1', stages[4].y + boxH/2 + 5)
                        .attr('x2', bracketX + 8).attr('y2', stages[4].y + boxH/2 + 5)
                        .attr('stroke', 'var(--accent-pink)').attr('stroke-width', 2).attr('opacity', 0.6);
                    svg.append('text').attr('x', bracketX - 10).attr('y', (stages[1].y + stages[4].y)/2 + 5)
                        .attr('text-anchor', 'middle').attr('fill', 'var(--accent-pink)')
                        .attr('font-size', '1.1rem').attr('font-weight', 'bold').text('×N');

                    // Descriptions on the left
                    const descs = [
                        'Token + position vectors',
                        'Each token attends to all others',
                        'Add skip connection, normalize',
                        'Two linear layers with ReLU',
                        'Add skip connection, normalize',
                        'To next block or final layer'
                    ];
                    const descTexts = descs.map((d, i) => {
                        return svg.append('text')
                            .attr('x', cx - boxW/2 - 50)
                            .attr('y', stages[i].y + 4)
                            .attr('text-anchor', 'end')
                            .attr('fill', 'var(--text-muted)')
                            .attr('font-size', '0.75rem')
                            .attr('opacity', 0);
                    });

                    // Trace animation
                    let animating = false;
                    document.getElementById('sim19-trace').onclick = () => {
                        if (animating) return;
                        animating = true;

                        // Reset
                        boxes.forEach(b => b.rect.attr('opacity', 0.9).style('filter', 'none'));
                        descTexts.forEach(t => t.attr('opacity', 0));
                        document.getElementById('sim19-status').innerText = '';

                        // Main data pulse
                        const pulse = svg.append('circle')
                            .attr('cx', cx).attr('cy', stages[0].y)
                            .attr('r', 8).attr('fill', stages[0].color)
                            .attr('opacity', 0).style('filter', 'url(#s19-glow)');

                        // Skip pulses
                        const skipPulse1 = svg.append('circle')
                            .attr('r', 5).attr('fill', '#8b5cf6').attr('opacity', 0)
                            .style('filter', 'url(#s19-glow)');
                        const skipPulse2 = svg.append('circle')
                            .attr('r', 5).attr('fill', '#10b981').attr('opacity', 0)
                            .style('filter', 'url(#s19-glow)');

                        const status = document.getElementById('sim19-status');
                        const stepDur = 800;

                        stages.forEach((s, i) => {
                            setTimeout(() => {
                                // Move main pulse
                                pulse.attr('opacity', 1).attr('fill', s.color)
                                    .transition().duration(350).ease(d3.easeCubicInOut)
                                    .attr('cy', s.y);

                                // Highlight box
                                boxes[i].rect.transition().duration(200)
                                    .style('filter', `drop-shadow(0 0 20px ${s.color})`).attr('opacity', 1);

                                // Show description
                                descTexts[i].text(descs[i]).transition().duration(300).attr('opacity', 0.7);

                                status.innerText = s.label;
                                status.style.color = s.color;

                                // Fire skip pulse at stage 0 (for skip 1)
                                if (i === 0) {
                                    setTimeout(() => {
                                        skipPulse1.attr('opacity', 0.8);
                                        skipPulse1
                                            .attr('cx', cx + boxW/2).attr('cy', stages[0].y);
                                        // Animate along skip path
                                        const skipLen1 = skip1.node().getTotalLength();
                                        let t1 = { t: 0 };
                                        d3.select(t1).transition().duration(stepDur * 2).ease(d3.easeLinear)
                                            .tween('skip1', () => (t) => {
                                                const pt = skip1.node().getPointAtLength(t * skipLen1);
                                                skipPulse1.attr('cx', pt.x).attr('cy', pt.y);
                                            })
                                            .on('end', () => skipPulse1.attr('opacity', 0));
                                    }, 200);
                                }

                                // Fire skip pulse at stage 2 (for skip 2)
                                if (i === 2) {
                                    setTimeout(() => {
                                        skipPulse2.attr('opacity', 0.8);
                                        skipPulse2
                                            .attr('cx', cx + boxW/2).attr('cy', stages[2].y);
                                        const skipLen2 = skip2.node().getTotalLength();
                                        let t2 = { t: 0 };
                                        d3.select(t2).transition().duration(stepDur * 2).ease(d3.easeLinear)
                                            .tween('skip2', () => (t) => {
                                                const pt = skip2.node().getPointAtLength(t * skipLen2);
                                                skipPulse2.attr('cx', pt.x).attr('cy', pt.y);
                                            })
                                            .on('end', () => skipPulse2.attr('opacity', 0));
                                    }, 200);
                                }

                                // Dim previous box
                                if (i > 0) {
                                    boxes[i-1].rect.transition().delay(200).duration(400)
                                        .style('filter', 'none').attr('opacity', 0.9);
                                }

                                // Final
                                if (i === stages.length - 1) {
                                    setTimeout(() => {
                                        pulse.transition().duration(400).attr('r', 14).attr('opacity', 0).remove();
                                        status.innerText = '✓ Data traced through one complete block';
                                        status.style.color = 'var(--accent-green)';
                                        boxes[i].rect.transition().delay(200).duration(400)
                                            .style('filter', 'none');
                                        animating = false;
                                    }, stepDur - 200);
                                }
                            }, i * stepDur + 200);
                        });
                    };
                }); });
            },

            'sim-20': (container) => { // Causal Masking - Enhanced
                const tokens = ["The","cat","sat","on","the","mat"];
                const size = tokens.length;
                // Random attention scores
                const scores = [];
                for (let i=0;i<size;i++) { scores[i]=[]; for(let j=0;j<size;j++) scores[i][j]=(Math.random()*2+0.5).toFixed(2); }

                container.innerHTML = `
                    <div style="height:100%; display:flex; flex-direction:column; align-items:center; padding:20px; box-sizing:border-box;">
                        <div style="display:flex; gap:30px; flex:1; min-height:0; align-items:center; justify-content:center;">
                            <div style="text-align:center;">
                                <div style="color:var(--text-secondary); margin-bottom:8px; font-size:0.95rem;">Raw Attention Scores</div>
                                <div id="sim20-raw" style="display:inline-grid; grid-template-columns:60px repeat(${size},50px); gap:3px;"></div>
                            </div>
                            <div style="font-size:2rem; color:var(--text-muted);">→</div>
                            <div style="text-align:center;">
                                <div style="color:var(--text-secondary); margin-bottom:8px; font-size:0.95rem;">After Mask + Softmax</div>
                                <div id="sim20-masked" style="display:inline-grid; grid-template-columns:60px repeat(${size},50px); gap:3px;"></div>
                            </div>
                        </div>
                        <div style="text-align:center; margin-top:10px;">
                            <button id="sim20-btn">Apply Causal Mask</button>
                            <div style="margin-top:8px; color:var(--text-muted); font-size:0.9rem;">Each token can only attend to previous tokens. The future is hidden.</div>
                        </div>
                    </div>
                `;

                function renderGrid(containerId, showMask) {
                    const el = document.getElementById(containerId);
                    el.innerHTML = '';
                    // Header row
                    el.innerHTML += '<div></div>';
                    tokens.forEach(t=>{ el.innerHTML += `<div style="text-align:center;color:var(--accent-blue);font-size:0.75rem;font-family:var(--font-mono);">${t}</div>`; });

                    for (let i=0;i<size;i++) {
                        el.innerHTML += `<div style="color:var(--accent-green);font-size:0.75rem;font-family:var(--font-mono);display:flex;align-items:center;">${tokens[i]}</div>`;
                        // Compute softmax for visible cells
                        let visible = [];
                        for (let j=0;j<size;j++) {
                            if (showMask && j>i) visible.push(null);
                            else visible.push(parseFloat(scores[i][j]));
                        }
                        const exps = visible.map(v=>v===null?0:Math.exp(v));
                        const sum = exps.reduce((a,b)=>a+b,0);
                        const probs = exps.map(v=>v/sum);

                        for (let j=0;j<size;j++) {
                            const isMasked = showMask && j>i;
                            const val = showMask ? (isMasked ? null : probs[j]) : parseFloat(scores[i][j]);
                            const display = isMasked ? '-∞' : (showMask ? (val*100).toFixed(0)+'%' : scores[i][j]);
                            const bg = isMasked ? '#1a1a2e' : (showMask ? `rgba(251,191,36,${Math.min(1,val*2)})` : 'var(--bg-elevated)');
                            const color = isMasked ? '#333' : (showMask && val>0.3 ? 'black' : 'white');
                            el.innerHTML += `<div style="width:50px;height:40px;display:flex;align-items:center;justify-content:center;font-size:0.75rem;font-family:var(--font-mono);background:${bg};color:${color};border-radius:4px;transition:all 0.5s;font-weight:${showMask&&val>0.3?'bold':'normal'};">${display}</div>`;
                        }
                    }
                }

                renderGrid('sim20-raw', false);
                renderGrid('sim20-masked', false);

                document.getElementById('sim20-btn').onclick = () => {
                    renderGrid('sim20-masked', true);
                };
            },

            'sim-21': (container) => { // Softmax - Enhanced with temperature
                const logits = [3.2, 2.1, 1.5, 0.8, 0.3, -0.2, -0.5, -1.0, -1.5, -2.0];
                const labels = ["cat","dog","the","sat","happy","on","running","beautiful","very","and"];
                let temperature = 1.0;
                let isProb = false;

                container.innerHTML = `
                    <div style="height:100%; display:flex; flex-direction:column; padding:20px; box-sizing:border-box;">
                        <div style="text-align:center; margin-bottom:10px;">
                            <div style="font-family:var(--font-mono); font-size:0.9rem; color:var(--text-muted);">P(i) = exp(z<sub>i</sub>/T) / &Sigma; exp(z<sub>j</sub>/T)</div>
                        </div>
                        <div id="sim21-viz" style="flex:1; min-height:0;"></div>
                        <div style="display:flex; gap:15px; align-items:center; justify-content:center; margin-top:10px;">
                            <button id="sim21-btn">Apply Softmax</button>
                            <label style="font-size:0.9rem;">Temperature: <span id="sim21-temp-val" style="color:var(--accent-amber); font-weight:bold;">1.0</span></label>
                            <input type="range" id="sim21-temp" min="0.1" max="2.0" step="0.1" value="1.0" style="width:150px;">
                        </div>
                        <div id="sim21-info" style="text-align:center; font-family:var(--font-mono); font-size:0.9rem; color:var(--text-secondary); min-height:25px; margin-top:8px;"></div>
                    </div>
                `;

                const vizEl = document.getElementById('sim21-viz');
                const w = vizEl.clientWidth, h = vizEl.clientHeight;
                const svg = d3.select("#sim21-viz").append("svg").attr("width",w).attr("height",h);
                const margin = {top:20,right:20,bottom:40,left:50};
                const gW = w-margin.left-margin.right, gH = h-margin.top-margin.bottom;
                const g = svg.append("g").attr("transform",`translate(${margin.left},${margin.top})`);

                const x = d3.scaleBand().domain(labels).range([0,gW]).padding(0.15);
                const y = d3.scaleLinear().range([gH,0]);

                g.append("g").attr("transform",`translate(0,${gH})`).call(d3.axisBottom(x)).attr("color","#94a3b8")
                    .selectAll("text").attr("font-size","11px");

                const yAxisG = g.append("g").attr("color","#64748b");

                function softmax(logits, temp) {
                    const scaled = logits.map(l=>l/temp);
                    const maxL = Math.max(...scaled);
                    const exps = scaled.map(l=>Math.exp(l-maxL));
                    const sum = exps.reduce((a,b)=>a+b,0);
                    return exps.map(e=>e/sum);
                }

                function render() {
                    let data, maxVal;
                    if (isProb) {
                        data = softmax(logits, temperature);
                        maxVal = 1;
                        y.domain([0, maxVal]);
                    } else {
                        data = logits;
                        maxVal = Math.max(...logits.map(Math.abs))+1;
                        y.domain([-maxVal, maxVal]);
                    }

                    yAxisG.transition().duration(500).call(d3.axisLeft(y).ticks(5));

                    const bars = g.selectAll("rect.bar").data(data);
                    bars.enter().append("rect").attr("class","bar").attr("rx",4)
                        .merge(bars)
                        .transition().duration(500)
                        .attr("x",(d,i)=>x(labels[i]))
                        .attr("y",d=>isProb ? y(d) : (d>=0 ? y(d) : y(0)))
                        .attr("width",x.bandwidth())
                        .attr("height",d=>isProb ? gH-y(d) : Math.abs(y(0)-y(d)))
                        .attr("fill",(d,i)=>{
                            if (!isProb) return d>=0?'var(--accent-blue)':'var(--accent-red)';
                            const maxP = Math.max(...softmax(logits,temperature));
                            return d===maxP ? 'var(--accent-amber)' : 'var(--accent-green)';
                        });

                    const lbls = g.selectAll("text.val").data(data);
                    lbls.enter().append("text").attr("class","val").attr("text-anchor","middle").attr("font-size","10px").attr("font-family","var(--font-mono)")
                        .merge(lbls)
                        .transition().duration(500)
                        .attr("x",(d,i)=>x(labels[i])+x.bandwidth()/2)
                        .attr("y",d=>isProb ? y(d)-5 : (d>=0 ? y(d)-5 : y(d)+15))
                        .attr("fill","white")
                        .text(d=>isProb ? (d*100).toFixed(1)+'%' : d.toFixed(1));

                    // Selected label
                    const sel = g.selectAll("text.sel").data(isProb?[1]:[]);
                    sel.enter().append("text").attr("class","sel").merge(sel)
                        .attr("x",()=>{const probs=softmax(logits,temperature); const maxI=probs.indexOf(Math.max(...probs)); return x(labels[maxI])+x.bandwidth()/2;})
                        .attr("y",()=>{const probs=softmax(logits,temperature); return y(Math.max(...probs))-20;})
                        .attr("text-anchor","middle").attr("fill","var(--accent-amber)").attr("font-size","11px").attr("font-weight","bold")
                        .text("Selected");
                    sel.exit().remove();

                    if (isProb) {
                        const probs = softmax(logits, temperature);
                        const maxI = probs.indexOf(Math.max(...probs));
                        const entropy = -probs.reduce((s,p)=>s+(p>0?p*Math.log2(p):0),0);
                        document.getElementById('sim21-info').textContent = `Temperature: ${temperature.toFixed(1)} | Top: "${labels[maxI]}" (${(probs[maxI]*100).toFixed(1)}%) | Entropy: ${entropy.toFixed(2)} bits`;
                    } else {
                        document.getElementById('sim21-info').textContent = 'Raw logits (before softmax)';
                    }
                }

                document.getElementById('sim21-btn').onclick = () => { isProb = true; render(); };
                document.getElementById('sim21-temp').oninput = (e) => {
                    temperature = parseFloat(e.target.value);
                    document.getElementById('sim21-temp-val').textContent = temperature.toFixed(1);
                    if (isProb) render();
                };
                render();
            },

            'sim-22': (container) => { // Full Forward Pass - Enhanced
                container.innerHTML = `
                    <div style="height:100%; display:flex; flex-direction:column; padding:15px; box-sizing:border-box;">
                        <div id="sim22-viz" style="flex:1; min-height:0;"></div>
                        <div id="sim22-stage" style="text-align:center; font-family:var(--font-mono); font-size:1rem; min-height:25px; color:var(--text-secondary); padding:5px;"></div>
                        <div style="text-align:center; padding:5px;">
                            <button id="sim22-btn">Trace Prediction</button>
                        </div>
                    </div>
                `;

                const el = document.getElementById('sim22-viz');
                const w = el.clientWidth, h = el.clientHeight;
                const svg = d3.select("#sim22-viz").append("svg").attr("width",w).attr("height",h);

                const stages = [
                    {label:'"Hello world"', color:'white', w:90},
                    {label:'Tokenizer', color:'var(--accent-purple)', w:80},
                    {label:'[Token IDs]', color:'var(--accent-blue)', w:80},
                    {label:'Embedding', color:'var(--accent-green)', w:80},
                    {label:'+ PosEnc', color:'var(--accent-amber)', w:70},
                    {label:'Transformer\nBlock ×N', color:'var(--accent-blue)', w:95},
                    {label:'Linear', color:'var(--accent-code)', w:60},
                    {label:'Softmax', color:'var(--accent-green)', w:65},
                    {label:'"is"', color:'var(--accent-amber)', w:50}
                ];

                const totalW = stages.reduce((s,st)=>s+st.w+15, 0);
                const scale = Math.min(1, (w-40)/totalW);
                const startX = (w - totalW*scale)/2;
                const cy = h*0.45;

                let xPos = startX;
                const stageData = stages.map((s,i)=>{
                    const x = xPos;
                    xPos += (s.w+15)*scale;
                    return {...s, x, cx:x+(s.w*scale)/2};
                });

                // Draw arrows
                stageData.slice(0,-1).forEach((s,i)=>{
                    svg.append("line")
                        .attr("x1",s.x+s.w*scale).attr("y1",cy)
                        .attr("x2",stageData[i+1].x).attr("y2",cy)
                        .attr("stroke","#444").attr("stroke-width",2);
                });

                // Draw boxes
                const boxG = svg.selectAll("g.stage").data(stageData).enter().append("g").attr("class","stage");
                boxG.append("rect")
                    .attr("x",d=>d.x).attr("y",cy-25).attr("width",d=>d.w*scale).attr("height",50)
                    .attr("fill","var(--bg-elevated)").attr("stroke",d=>d.color).attr("stroke-width",2).attr("rx",8)
                    .attr("class","stage-box");
                boxG.each(function(d) {
                    const lines = d.label.split('\n');
                    const g = d3.select(this);
                    lines.forEach((line,i) => {
                        g.append("text").text(line)
                            .attr("x",d.cx).attr("y",cy+2+(i-lines.length/2+0.5)*14)
                            .attr("text-anchor","middle").attr("fill","white").attr("font-size",scale>0.7?"11px":"9px").attr("font-weight","bold");
                    });
                });

                // Stage labels below
                const stageLabels = ["Input","Split","Lookup","Vectors","Position","Process","Project","Probabilities","Output"];
                boxG.append("text").text((d,i)=>stageLabels[i]||'')
                    .attr("x",d=>d.cx).attr("y",cy+38).attr("text-anchor","middle").attr("fill","var(--text-muted)").attr("font-size","9px");

                const pulse = svg.append("circle").attr("r",8).attr("fill","var(--accent-green)").attr("opacity",0);

                document.getElementById('sim22-btn').onclick = () => {
                    const stage = document.getElementById('sim22-stage');
                    const descriptions = [
                        'Input text: "Hello world"',
                        'Tokenizing: splitting into subword tokens...',
                        'Token IDs: [15496, 995]',
                        'Looking up embedding vectors...',
                        'Adding positional encoding waves...',
                        'Processing through N transformer blocks (attention + FFN)...',
                        'Linear projection to vocabulary size (50,000)...',
                        'Softmax: converting to probabilities...',
                        'Next token predicted: "is" (42.3%)'
                    ];

                    pulse.attr("cx",stageData[0].cx).attr("cy",cy).attr("opacity",0.9).attr("fill","var(--accent-green)");

                    // Reset all boxes
                    svg.selectAll(".stage-box").attr("fill","var(--bg-elevated)");

                    stageData.forEach((s,i) => {
                        setTimeout(()=>{
                            stage.textContent = descriptions[i];
                            stage.style.color = s.color;

                            // Highlight current box
                            svg.selectAll(".stage-box").attr("fill","var(--bg-elevated)");
                            svg.selectAll(".stage-box").filter((_,j)=>j===i)
                                .transition().duration(200).attr("fill",s.color).attr("fill-opacity",0.2);

                            pulse.transition().duration(500).attr("cx",s.cx).attr("fill",s.color);

                            if (i === stageData.length-1) {
                                setTimeout(()=>{ pulse.transition().duration(500).attr("r",15).attr("fill","var(--accent-amber)").transition().duration(300).attr("r",8); }, 500);
                            }
                        }, i*900);
                    });
                };
            },
            'sim-neuron': (container) => { // Interactive Artificial Neuron
                const W = container.clientWidth || 900;
                const H = container.clientHeight || 500;

                container.innerHTML = `
                    <div style="height:100%; display:flex; flex-direction:column; align-items:center; padding:15px; box-sizing:border-box;">
                        <div style="display:flex; gap:20px; align-items:center; margin-bottom:10px;">
                            <label style="color:var(--text-secondary); font-size:0.9rem;">Activation:</label>
                            <select id="neuron-act" style="padding:6px 12px; background:var(--bg-elevated); color:var(--text-primary); border:1px solid var(--border-subtle); border-radius:6px; font-size:0.9rem;">
                                <option value="step">Step</option>
                                <option value="sigmoid" selected>Sigmoid</option>
                                <option value="relu">ReLU</option>
                            </select>
                            <label style="color:var(--text-secondary); font-size:0.9rem;">Bias:</label>
                            <input type="range" id="neuron-bias" min="-3" max="3" step="0.1" value="0" style="width:100px;">
                            <span id="neuron-bias-val" style="color:var(--accent-amber); font-weight:bold; min-width:40px;">0.0</span>
                            <button id="neuron-fire-btn" style="padding:8px 20px; background:linear-gradient(135deg, var(--accent-blue), var(--accent-purple)); border:none; border-radius:8px; font-weight:bold; cursor:pointer; font-size:0.9rem; color:white; box-shadow:0 4px 15px rgba(56,189,248,0.3);">⚡ Fire</button>
                        </div>
                        <div id="neuron-svg-wrap" style="flex:1; width:100%; min-height:0;"></div>
                        <div id="neuron-status" style="color:var(--text-secondary); font-size:1rem; min-height:25px; font-weight:600; text-align:center;"></div>
                    </div>
                `;

                requestAnimationFrame(() => { requestAnimationFrame(() => {
                    const wrap = document.getElementById('neuron-svg-wrap');
                    const w = wrap.clientWidth || 800;
                    const h = wrap.clientHeight || 380;
                    const svg = d3.select(wrap).append('svg').attr('width', w).attr('height', h);

                    // Defs for glow
                    const defs = svg.append('defs');
                    const glow = defs.append('filter').attr('id','neuron-glow').attr('x','-50%').attr('y','-50%').attr('width','200%').attr('height','200%');
                    glow.append('feGaussianBlur').attr('stdDeviation','4').attr('result','blur');
                    const merge = glow.append('feMerge');
                    merge.append('feMergeNode').attr('in','blur');
                    merge.append('feMergeNode').attr('in','SourceGraphic');

                    // Layout
                    const inputs = [
                        { label: 'x₁', y: h*0.15, val: 1.0, weight: 0.5 },
                        { label: 'x₂', y: h*0.38, val: 0.5, weight: -0.3 },
                        { label: 'x₃', y: h*0.62, val: -0.8, weight: 0.8 },
                        { label: 'x₄', y: h*0.85, val: 0.2, weight: -0.5 }
                    ];
                    const inputX = w * 0.08;
                    const sliderX = w * 0.17;
                    const sumX = w * 0.48;
                    const sumY = h * 0.5;
                    const actX = w * 0.68;
                    const outX = w * 0.88;

                    // Draw connections (input -> sum)
                    const connGroup = svg.append('g');
                    const connections = inputs.map((inp, i) => {
                        const line = connGroup.append('line')
                            .attr('x1', sliderX + 80).attr('y1', inp.y)
                            .attr('x2', sumX - 30).attr('y2', sumY)
                            .attr('stroke', inp.weight >= 0 ? 'var(--accent-blue)' : 'var(--accent-pink)')
                            .attr('stroke-width', Math.abs(inp.weight) * 4 + 1)
                            .attr('opacity', 0.6);
                        const wLabel = connGroup.append('text')
                            .attr('x', (sliderX + 80 + sumX - 30) / 2)
                            .attr('y', (inp.y + sumY) / 2 - 8)
                            .attr('text-anchor', 'middle')
                            .attr('fill', inp.weight >= 0 ? 'var(--accent-blue)' : 'var(--accent-pink)')
                            .attr('font-size', '0.8rem')
                            .attr('font-weight', 'bold')
                            .text(`w=${inp.weight.toFixed(1)}`);
                        return { line, wLabel };
                    });

                    // Sum -> Act connection
                    svg.append('line')
                        .attr('x1', sumX + 30).attr('y1', sumY)
                        .attr('x2', actX - 40).attr('y2', sumY)
                        .attr('stroke', 'var(--text-muted)').attr('stroke-width', 2).attr('opacity', 0.5);

                    // Act -> Output connection
                    svg.append('line')
                        .attr('x1', actX + 40).attr('y1', sumY)
                        .attr('x2', outX - 25).attr('y2', sumY)
                        .attr('stroke', 'var(--text-muted)').attr('stroke-width', 2).attr('opacity', 0.5);

                    // Input nodes and sliders
                    inputs.forEach((inp, i) => {
                        // Node circle
                        svg.append('circle')
                            .attr('cx', inputX).attr('cy', inp.y).attr('r', 18)
                            .attr('fill', 'var(--bg-elevated)').attr('stroke', 'var(--accent-blue)').attr('stroke-width', 2);
                        svg.append('text')
                            .attr('x', inputX).attr('y', inp.y + 5)
                            .attr('text-anchor', 'middle').attr('fill', 'var(--accent-blue)')
                            .attr('font-size', '0.9rem').attr('font-weight', 'bold').text(inp.label);

                        // Slider via foreignObject
                        const fo = svg.append('foreignObject')
                            .attr('x', sliderX).attr('y', inp.y - 12).attr('width', 80).attr('height', 24);
                        const slider = fo.append('xhtml:input')
                            .attr('type', 'range').attr('min', '-2').attr('max', '2').attr('step', '0.1')
                            .attr('value', inp.val)
                            .style('width', '75px').style('cursor', 'pointer');
                        slider.on('input', function() {
                            inp.val = parseFloat(this.value);
                            valText.text(inp.val.toFixed(1));
                            updateOutput();
                        });
                        const valText = svg.append('text')
                            .attr('x', sliderX + 85).attr('y', inp.y + 5)
                            .attr('fill', 'var(--text-primary)').attr('font-size', '0.8rem')
                            .attr('font-weight', 'bold').text(inp.val.toFixed(1));
                    });

                    // Summation node
                    svg.append('circle')
                        .attr('cx', sumX).attr('cy', sumY).attr('r', 28)
                        .attr('fill', 'var(--bg-elevated)').attr('stroke', 'var(--accent-purple)').attr('stroke-width', 2.5);
                    svg.append('text')
                        .attr('x', sumX).attr('y', sumY + 8)
                        .attr('text-anchor', 'middle').attr('fill', 'var(--accent-purple)')
                        .attr('font-size', '1.6rem').attr('font-weight', 'bold').text('Σ');
                    const sumValText = svg.append('text')
                        .attr('x', sumX).attr('y', sumY + 48)
                        .attr('text-anchor', 'middle').attr('fill', 'var(--text-secondary)')
                        .attr('font-size', '0.85rem');

                    // Activation function node
                    svg.append('rect')
                        .attr('x', actX - 38).attr('y', sumY - 38).attr('width', 76).attr('height', 76)
                        .attr('rx', 10).attr('fill', 'var(--bg-elevated)').attr('stroke', 'var(--accent-amber)').attr('stroke-width', 2.5);
                    svg.append('text')
                        .attr('x', actX).attr('y', sumY - 44)
                        .attr('text-anchor', 'middle').attr('fill', 'var(--accent-amber)')
                        .attr('font-size', '0.75rem').attr('font-weight', 'bold').text('Activation');
                    // Mini activation plot inside the box
                    const actPlotG = svg.append('g').attr('transform', `translate(${actX - 30}, ${sumY - 28})`);
                    const actPlotW = 60, actPlotH = 56;

                    function drawActPlot(type) {
                        actPlotG.selectAll('*').remove();
                        // Axes
                        actPlotG.append('line').attr('x1',0).attr('y1',actPlotH/2).attr('x2',actPlotW).attr('y2',actPlotH/2)
                            .attr('stroke','var(--text-muted)').attr('stroke-width',0.5).attr('opacity',0.4);
                        actPlotG.append('line').attr('x1',actPlotW/2).attr('y1',0).attr('x2',actPlotW/2).attr('y2',actPlotH)
                            .attr('stroke','var(--text-muted)').attr('stroke-width',0.5).attr('opacity',0.4);
                        const pts = [];
                        for (let t = -4; t <= 4; t += 0.2) {
                            let v;
                            if (type === 'step') v = t >= 0 ? 1 : 0;
                            else if (type === 'sigmoid') v = 1 / (1 + Math.exp(-t));
                            else v = Math.max(0, t) / 4; // relu scaled
                            const px = (t + 4) / 8 * actPlotW;
                            const py = actPlotH - v * actPlotH;
                            pts.push([px, py]);
                        }
                        const lineGen = d3.line().x(d=>d[0]).y(d=>d[1]).curve(d3.curveMonotoneX);
                        actPlotG.append('path').attr('d', lineGen(pts))
                            .attr('fill','none').attr('stroke','var(--accent-amber)').attr('stroke-width',2);
                    }
                    drawActPlot('sigmoid');

                    // Output node
                    const outCircle = svg.append('circle')
                        .attr('cx', outX).attr('cy', sumY).attr('r', 22)
                        .attr('fill', 'var(--bg-elevated)').attr('stroke', 'var(--accent-green)').attr('stroke-width', 2.5);
                    const outValText = svg.append('text')
                        .attr('x', outX).attr('y', sumY + 6)
                        .attr('text-anchor', 'middle').attr('fill', 'var(--accent-green)')
                        .attr('font-size', '1.1rem').attr('font-weight', 'bold').text('?');
                    svg.append('text')
                        .attr('x', outX).attr('y', sumY - 30)
                        .attr('text-anchor', 'middle').attr('fill', 'var(--text-secondary)')
                        .attr('font-size', '0.8rem').text('Output');

                    function activate(z, type) {
                        if (type === 'step') return z >= 0 ? 1 : 0;
                        if (type === 'sigmoid') return 1 / (1 + Math.exp(-z));
                        return Math.max(0, z);
                    }

                    function updateOutput() {
                        const bias = parseFloat(document.getElementById('neuron-bias').value);
                        const actType = document.getElementById('neuron-act').value;
                        let z = bias;
                        inputs.forEach(inp => { z += inp.val * inp.weight; });
                        const out = activate(z, actType);
                        sumValText.text(`z = ${z.toFixed(2)}`);
                        outValText.text(out.toFixed(3));
                        outCircle.attr('stroke', out > 0.5 ? 'var(--accent-green)' : 'var(--accent-pink)');
                        document.getElementById('neuron-status').innerText =
                            `Σ(wᵢxᵢ) + b = ${z.toFixed(2)}  →  ${actType}(${z.toFixed(2)}) = ${out.toFixed(3)}`;
                    }

                    // Event listeners
                    document.getElementById('neuron-act').onchange = function() {
                        drawActPlot(this.value);
                        updateOutput();
                    };
                    document.getElementById('neuron-bias').oninput = function() {
                        document.getElementById('neuron-bias-val').textContent = parseFloat(this.value).toFixed(1);
                        updateOutput();
                    };

                    // Fire button - animated pulse
                    document.getElementById('neuron-fire-btn').onclick = () => {
                        const actType = document.getElementById('neuron-act').value;
                        const bias = parseFloat(document.getElementById('neuron-bias').value);

                        inputs.forEach((inp, i) => {
                            const color = inp.val * inp.weight >= 0 ? 'var(--accent-blue)' : 'var(--accent-pink)';
                            const pulse = svg.append('circle')
                                .attr('cx', sliderX + 80).attr('cy', inp.y)
                                .attr('r', 6).attr('fill', color).attr('opacity', 0.9)
                                .style('filter', 'url(#neuron-glow)');
                            pulse.transition().duration(600).delay(i * 100)
                                .attr('cx', sumX - 30).attr('cy', sumY)
                                .attr('r', 4).attr('opacity', 0)
                                .remove();
                        });

                        // Pulse from sum to activation
                        setTimeout(() => {
                            const p2 = svg.append('circle')
                                .attr('cx', sumX + 30).attr('cy', sumY)
                                .attr('r', 6).attr('fill', 'var(--accent-purple)').attr('opacity', 0.9)
                                .style('filter', 'url(#neuron-glow)');
                            p2.transition().duration(400)
                                .attr('cx', actX - 40).attr('opacity', 0).remove();

                            // Glow sum node
                            svg.select('circle[stroke="var(--accent-purple)"]')
                                .transition().duration(200).attr('stroke-width', 5)
                                .transition().duration(300).attr('stroke-width', 2.5);
                        }, 600);

                        // Pulse from activation to output
                        setTimeout(() => {
                            const p3 = svg.append('circle')
                                .attr('cx', actX + 40).attr('cy', sumY)
                                .attr('r', 6).attr('fill', 'var(--accent-amber)').attr('opacity', 0.9)
                                .style('filter', 'url(#neuron-glow)');
                            p3.transition().duration(400)
                                .attr('cx', outX - 25).attr('opacity', 0).remove();

                            // Glow output
                            outCircle.transition().duration(200).attr('stroke-width', 5).attr('r', 28)
                                .transition().duration(400).attr('stroke-width', 2.5).attr('r', 22);
                        }, 1100);

                        updateOutput();
                    };

                    updateOutput();
                }); });
            },

            'sim-embed-3d': (container) => { // 3D Word Embedding Visualization
                container.innerHTML = `
                    <div id="embed3d-container" style="width:100%; height:100%; position:relative;">
                        <div id="embed3d-scene" style="width:100%; height:100%;"></div>
                        <div id="embed3d-legend" style="position:absolute; bottom:20px; left:20px; background:rgba(0,0,0,0.85); padding:15px; border-radius:10px; font-size:12px; border:1px solid rgba(255,255,255,0.1);">
                            <div style="margin-bottom:8px; color:var(--text-secondary); font-weight:bold;">Word Categories:</div>
                            <div><span style="color:#f59e0b;">●</span> Animals</div>
                            <div><span style="color:#22c55e;">●</span> Food</div>
                            <div><span style="color:#a855f7;">●</span> Royalty</div>
                            <div><span style="color:#3b82f6;">●</span> Actions</div>
                            <div><span style="color:#eab308;">●</span> Places</div>
                        </div>
                        <div id="embed3d-status" style="position:absolute; top:20px; left:50%; transform:translateX(-50%); background:rgba(0,0,0,0.85); padding:10px 25px; border-radius:20px; font-size:14px; color:var(--accent-blue); border:1px solid rgba(255,255,255,0.1);">
                            Training: Epoch 0
                        </div>
                    </div>
                `;

                const sceneContainer = document.getElementById('embed3d-scene');
                const width = sceneContainer.clientWidth;
                const height = sceneContainer.clientHeight;

                // Three.js Setup
                const scene = new THREE.Scene();
                scene.background = new THREE.Color(0x050810);

                const camera = new THREE.PerspectiveCamera(60, width / height, 0.1, 1000);
                camera.position.set(6.5, 5.5, 6.5);
                camera.lookAt(1.5, 1.5, 1.5);

                const renderer = new THREE.WebGLRenderer({ antialias: true });
                renderer.setSize(width, height);
                renderer.setPixelRatio(window.devicePixelRatio);
                sceneContainer.appendChild(renderer.domElement);

                // Add lighting for solid planet-like spheres
                const ambientLight = new THREE.AmbientLight(0x404040, 0.5);
                scene.add(ambientLight);

                const directionalLight = new THREE.DirectionalLight(0xffffff, 1.2);
                directionalLight.position.set(5, 10, 7);
                scene.add(directionalLight);

                const pointLight = new THREE.PointLight(0x38bdf8, 0.8, 20);
                pointLight.position.set(-3, 3, 3);
                scene.add(pointLight);

                // Create matplotlib-style 3D Axes with tick marks
                const axisLength = 3;
                const axisColor = 0x666666;
                const tickCount = 5;

                // Helper to create tick label
                function createTickLabel(text, position) {
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    canvas.width = 48;
                    canvas.height = 24;
                    ctx.fillStyle = '#888888';
                    ctx.font = '16px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText(text, 24, 18);
                    const texture = new THREE.CanvasTexture(canvas);
                    const spriteMat = new THREE.SpriteMaterial({ map: texture, transparent: true });
                    const sprite = new THREE.Sprite(spriteMat);
                    sprite.position.set(...position);
                    sprite.scale.set(0.4, 0.2, 1);
                    scene.add(sprite);
                }

                // X Axis with ticks
                const xAxisGeom = new THREE.BufferGeometry().setFromPoints([
                    new THREE.Vector3(0, 0, 0),
                    new THREE.Vector3(axisLength, 0, 0)
                ]);
                const xAxisMat = new THREE.LineBasicMaterial({ color: axisColor });
                scene.add(new THREE.Line(xAxisGeom, xAxisMat));

                // X tick marks and labels
                for (let i = 0; i <= tickCount; i++) {
                    const x = (i / tickCount) * axisLength;
                    const tickGeom = new THREE.BufferGeometry().setFromPoints([
                        new THREE.Vector3(x, -0.1, 0),
                        new THREE.Vector3(x, 0.1, 0)
                    ]);
                    scene.add(new THREE.Line(tickGeom, new THREE.LineBasicMaterial({ color: axisColor })));
                    createTickLabel((i * 0.2).toFixed(1), [x, -0.3, 0]);
                }
                createTickLabel('x', [axisLength + 0.3, 0, 0]);

                // Y Axis with ticks
                const yAxisGeom = new THREE.BufferGeometry().setFromPoints([
                    new THREE.Vector3(0, 0, 0),
                    new THREE.Vector3(0, axisLength, 0)
                ]);
                const yAxisMat = new THREE.LineBasicMaterial({ color: axisColor });
                scene.add(new THREE.Line(yAxisGeom, yAxisMat));

                // Y tick marks and labels
                for (let i = 0; i <= tickCount; i++) {
                    const y = (i / tickCount) * axisLength;
                    const tickGeom = new THREE.BufferGeometry().setFromPoints([
                        new THREE.Vector3(-0.1, y, 0),
                        new THREE.Vector3(0.1, y, 0)
                    ]);
                    scene.add(new THREE.Line(tickGeom, new THREE.LineBasicMaterial({ color: axisColor })));
                    createTickLabel((i * 0.2).toFixed(1), [-0.4, y, 0]);
                }
                createTickLabel('y', [0, axisLength + 0.3, 0]);

                // Z Axis with ticks
                const zAxisGeom = new THREE.BufferGeometry().setFromPoints([
                    new THREE.Vector3(0, 0, 0),
                    new THREE.Vector3(0, 0, axisLength)
                ]);
                const zAxisMat = new THREE.LineBasicMaterial({ color: axisColor });
                scene.add(new THREE.Line(zAxisGeom, zAxisMat));

                // Z tick marks and labels
                for (let i = 0; i <= tickCount; i++) {
                    const z = (i / tickCount) * axisLength;
                    const tickGeom = new THREE.BufferGeometry().setFromPoints([
                        new THREE.Vector3(0, -0.1, z),
                        new THREE.Vector3(0, 0.1, z)
                    ]);
                    scene.add(new THREE.Line(tickGeom, new THREE.LineBasicMaterial({ color: axisColor })));
                    createTickLabel((i * 0.2).toFixed(1), [0, -0.3, z]);
                }
                createTickLabel('z', [0, 0, axisLength + 0.3]);

                // Add grid planes (like matplotlib)
                const gridHelper = new THREE.GridHelper(axisLength, 10, 0x333333, 0x222222);
                gridHelper.position.set(axisLength / 2, 0, axisLength / 2);
                scene.add(gridHelper);

                // Words with categories and target positions (spread out to avoid overlap)
                const words = [
                    // Animals (orange) - cluster bottom-left of grid
                    { word: "cat", category: "animal", color: 0xf59e0b, target: [0.2, 0.3, 0.2] },
                    { word: "dog", category: "animal", color: 0xf59e0b, target: [0.5, 0.5, 0.3] },
                    { word: "bird", category: "animal", color: 0xf59e0b, target: [0.3, 0.7, 0.1] },
                    { word: "fish", category: "animal", color: 0xf59e0b, target: [0.1, 0.5, 0.5] },
                    { word: "lion", category: "animal", color: 0xf59e0b, target: [0.6, 0.4, 0.4] },

                    // Food (green) - cluster far right side
                    { word: "apple", category: "food", color: 0x22c55e, target: [2.5, 0.3, 0.2] },
                    { word: "bread", category: "food", color: 0x22c55e, target: [2.8, 0.5, 0.4] },
                    { word: "cheese", category: "food", color: 0x22c55e, target: [2.4, 0.7, 0.3] },
                    { word: "pizza", category: "food", color: 0x22c55e, target: [2.6, 0.4, 0.6] },
                    { word: "banana", category: "food", color: 0x22c55e, target: [2.7, 0.6, 0.1] },

                    // Royalty (purple) - cluster top center (high Y)
                    { word: "king", category: "royalty", color: 0xa855f7, target: [1.3, 2.6, 0.3] },
                    { word: "queen", category: "royalty", color: 0xa855f7, target: [1.6, 2.8, 0.5] },
                    { word: "prince", category: "royalty", color: 0xa855f7, target: [1.1, 2.4, 0.2] },
                    { word: "princess", category: "royalty", color: 0xa855f7, target: [1.5, 2.5, 0.6] },
                    { word: "throne", category: "royalty", color: 0xa855f7, target: [1.2, 2.7, 0.4] },

                    // Actions (blue) - cluster front-left (high Z)
                    { word: "run", category: "action", color: 0x3b82f6, target: [0.3, 1.4, 2.5] },
                    { word: "walk", category: "action", color: 0x3b82f6, target: [0.6, 1.2, 2.7] },
                    { word: "jump", category: "action", color: 0x3b82f6, target: [0.4, 1.6, 2.3] },
                    { word: "swim", category: "action", color: 0x3b82f6, target: [0.2, 1.3, 2.8] },
                    { word: "fly", category: "action", color: 0x3b82f6, target: [0.5, 1.5, 2.4] },

                    // Places (amber/yellow) - cluster right-front
                    { word: "city", category: "place", color: 0xeab308, target: [2.3, 1.5, 2.4] },
                    { word: "home", category: "place", color: 0xeab308, target: [2.6, 1.3, 2.6] },
                    { word: "park", category: "place", color: 0xeab308, target: [2.2, 1.7, 2.2] },
                    { word: "beach", category: "place", color: 0xeab308, target: [2.5, 1.4, 2.7] },
                    { word: "mountain", category: "place", color: 0xeab308, target: [2.4, 1.6, 2.5] }
                ];

                // Create word spheres (solid, planet-like)
                const wordMeshes = [];
                words.forEach(w => {
                    const startPos = [
                        Math.random() * 3,
                        Math.random() * 3,
                        Math.random() * 3
                    ];

                    // Solid sphere with lighting (planet-like) - smaller size to prevent overlap
                    const geometry = new THREE.SphereGeometry(0.14, 32, 32);
                    const material = new THREE.MeshStandardMaterial({
                        color: w.color,
                        roughness: 0.3,
                        metalness: 0.2,
                        emissive: w.color,
                        emissiveIntensity: 0.15
                    });
                    const sphere = new THREE.Mesh(geometry, material);
                    sphere.position.set(...startPos);
                    scene.add(sphere);

                    // Word label (just name)
                    const canvas = document.createElement('canvas');
                    const context = canvas.getContext('2d');
                    canvas.width = 256;
                    canvas.height = 64;

                    // Draw word name
                    context.fillStyle = '#ffffff';
                    context.font = 'bold 28px Arial';
                    context.textAlign = 'center';
                    context.fillText(w.word, 128, 40);

                    const texture = new THREE.CanvasTexture(canvas);
                    const spriteMaterial = new THREE.SpriteMaterial({
                        map: texture,
                        transparent: true
                    });
                    const sprite = new THREE.Sprite(spriteMaterial);
                    sprite.scale.set(1.1, 0.28, 1);
                    sprite.position.set(...startPos);
                    sprite.position.y += 0.35;
                    scene.add(sprite);

                    wordMeshes.push({
                        sphere,
                        sprite,
                        canvas,
                        context,
                        texture,
                        startPos,
                        targetPos: w.target,
                        word: w.word
                    });
                });

                // Relationship lines
                const relationships = [
                    { from: "king", to: "queen", color: 0xa855f7 },
                    { from: "cat", to: "dog", color: 0xf59e0b },
                    { from: "run", to: "walk", color: 0x3b82f6 },
                    { from: "apple", to: "banana", color: 0x22c55e },
                    { from: "city", to: "home", color: 0xeab308 },
                    { from: "prince", to: "princess", color: 0xa855f7 },
                    { from: "bird", to: "fish", color: 0xf59e0b },
                    { from: "jump", to: "fly", color: 0x3b82f6 }
                ];

                const lineMeshes = [];

                function createCurvedLine(from, to, color) {
                    const midPoint = new THREE.Vector3(
                        (from.x + to.x) / 2 + (Math.random() - 0.5) * 0.3,
                        (from.y + to.y) / 2 + (Math.random() - 0.5) * 0.3,
                        (from.z + to.z) / 2 + 0.3
                    );

                    const curve = new THREE.QuadraticBezierCurve3(from, midPoint, to);
                    const points = curve.getPoints(20);
                    const geometry = new THREE.BufferGeometry().setFromPoints(points);
                    const material = new THREE.LineBasicMaterial({
                        color: color,
                        transparent: true,
                        opacity: 0.8,
                        linewidth: 3
                    });
                    const line = new THREE.Line(geometry, material);
                    scene.add(line);
                    return { line, material };
                }

                // Animation state
                let trainProgress = 0;
                const trainDuration = 6000;
                const startTime = Date.now();
                let linesCreated = false;

                // Animation loop
                let animFrameId;
                function animate() {
                    animFrameId = requestAnimationFrame(animate);

                    const elapsed = Date.now() - startTime;
                    trainProgress = Math.min(1, elapsed / trainDuration);

                    // Update epoch display
                    const epoch = Math.floor(trainProgress * 100);
                    const status = document.getElementById('embed3d-status');
                    if (status) {
                        if (trainProgress < 1) {
                            status.textContent = `Training: Epoch ${epoch} `;
                            status.style.color = 'var(--accent-blue)';
                        } else {
                            status.textContent = 'Training Complete ✓';
                            status.style.color = 'var(--accent-green)';
                        }
                    }

                    // Animate word positions
                    const easeProgress = 1 - Math.pow(1 - trainProgress, 3);
                    wordMeshes.forEach(w => {
                        const x = w.startPos[0] + (w.targetPos[0] - w.startPos[0]) * easeProgress;
                        const y = w.startPos[1] + (w.targetPos[1] - w.startPos[1]) * easeProgress;
                        const z = w.startPos[2] + (w.targetPos[2] - w.startPos[2]) * easeProgress;

                        w.sphere.position.set(x, y, z);
                        w.sprite.position.set(x, y + 0.3, z);
                    });

                    // Create relationship lines after training
                    if (trainProgress > 0.7 && !linesCreated) {
                        linesCreated = true;
                        relationships.forEach(r => {
                            const fromWord = wordMeshes.find(w => w.word === r.from);
                            const toWord = wordMeshes.find(w => w.word === r.to);
                            if (fromWord && toWord) {
                                const { line, material } = createCurvedLine(
                                    fromWord.sphere.position.clone(),
                                    toWord.sphere.position.clone(),
                                    r.color
                                );
                                lineMeshes.push({ line, material });
                            }
                        });
                    }

                    // Fade in lines
                    if (linesCreated) {
                        const lineProgress = Math.min(1, (trainProgress - 0.7) / 0.3);
                        lineMeshes.forEach(l => {
                            l.material.opacity = lineProgress * 0.7;
                        });
                    }

                    // Gentle rotation after training
                    if (trainProgress >= 1) {
                        scene.rotation.y += 0.003;
                    }

                    renderer.render(scene, camera);
                }

                animate();

                // Handle resize
                const resizeHandler = () => {
                    const w = sceneContainer.clientWidth;
                    const h = sceneContainer.clientHeight;
                    if (w > 0 && h > 0) {
                        camera.aspect = w / h;
                        camera.updateProjectionMatrix();
                        renderer.setSize(w, h);
                    }
                };
                window.addEventListener('resize', resizeHandler);

                // Register cleanup for Three.js resources
                app.activeCleanups.push(() => {
                    cancelAnimationFrame(animFrameId);
                    window.removeEventListener('resize', resizeHandler);
                    renderer.dispose();
                });
            },

            'sim-23': (container) => { // Full Arc
                container.innerHTML = `
                    <div style="height:100%; display:flex; align-items:center; justify-content:center;">
                        <h2 style="color:var(--accent-green);">The Transformer has been built.</h2>
                    </div>
                `;
            }
        };

        // --- State Management ---
        const state = {
            currentSlide: 0,
            notesVisible: false,
            overviewActive: false,
            totalSlides: SLIDES.length
        };

        // --- Core Engine ---
        const app = {
            activeCleanups: [],

            init() {
                this.dom = {
                    viewer: document.getElementById('slide-viewer'),
                    progressBar: document.getElementById('progress-bar'),
                    progressBg: document.getElementById('progress-bg'),
                    counter: document.getElementById('slide-counter'),
                    notesPanel: document.getElementById('notes-panel'),
                    notesContent: document.getElementById('notes-content'),
                    gotoModal: document.getElementById('goto-modal'),
                    gotoInput: document.getElementById('goto-input'),
                    overviewGrid: document.getElementById('overview-grid')
                };

                this.bindEvents();
                this.renderOverview();
                this.checkHash();

                // If no hash, render first slide
                if (state.currentSlide === 0) this.goToSlide(0);
            },

            bindEvents() {
                // Keyboard
                document.addEventListener('keydown', (e) => {
                    if (this.dom.gotoModal.classList.contains('active')) {
                        if (e.key === 'Escape') this.toggleGoto(false);
                        if (e.key === 'Enter') this.submitGoto();
                        return;
                    }
                    if (state.overviewActive) {
                        if (e.key === 'Escape' || e.key === 'o' || e.key === 'O') this.toggleOverview();
                        return;
                    }

                    switch (e.key) {
                        case 'ArrowRight':
                        case ' ': // Space
                        case 'PageDown':
                            this.nextSlide();
                            break;
                        case 'ArrowLeft':
                        case 'PageUp':
                            this.prevSlide();
                            break;
                        case 'f':
                        case 'F':
                            this.toggleFullscreen();
                            break;
                        case 's':
                        case 'S':
                            this.toggleNotes();
                            break;
                        case 'o':
                        case 'O':
                            this.toggleOverview();
                            break;
                        case 'g':
                        case 'G':
                            this.toggleGoto(true);
                            e.preventDefault();
                            break;
                    }
                });

                // Hash change
                window.addEventListener('hashchange', () => this.checkHash());

                // Click progress to jump
                this.dom.progressBg.addEventListener('click', (e) => {
                    const rect = this.dom.progressBg.getBoundingClientRect();
                    const percent = (e.clientX - rect.left) / rect.width;
                    const slideIndex = Math.floor(percent * SLIDES.length);
                    this.goToSlide(slideIndex);
                });
            },

            checkHash() {
                const hash = window.location.hash.replace('#/', '');
                const index = parseInt(hash, 10) - 1;
                if (!isNaN(index) && index >= 0 && index < SLIDES.length && index !== state.currentSlide) {
                    this.goToSlide(index, false); // false = don't push hash again
                }
            },

            goToSlide(index, updateHash = true) {
                if (index < 0) index = 0;
                if (index >= SLIDES.length) index = SLIDES.length - 1;

                state.currentSlide = index;

                // Update UI
                this.renderSlide(index);
                this.updateProgress();
                this.updateNotes();

                if (updateHash) {
                    window.location.hash = `/${index + 1}`;
                }
            },

            nextSlide() {
                this.goToSlide(state.currentSlide + 1);
            },

            prevSlide() {
                this.goToSlide(state.currentSlide - 1);
            },

            renderSlide(index) {
                const slide = SLIDES[index];
                const viewer = this.dom.viewer;

                // Clean up previous slide's resources (Three.js, animation loops, etc.)
                this.activeCleanups.forEach(fn => { try { fn(); } catch(e) { console.warn('Cleanup error:', e); } });
                this.activeCleanups = [];

                // Fade out (simple implementation: clear and rebuild.
                // For smoother transitions, we could double-buffer slides)
                viewer.style.opacity = 0;

                setTimeout(() => {
                    viewer.innerHTML = ''; // Clear

                    // Build Slide HTML based on layout
                    const el = document.createElement('div');
                    el.className = 'slide-content';
                    el.innerHTML = this.getLayoutHTML(slide);

                    // Apply layout specific class
                    el.classList.add(`layout-${slide.layout}`);

                    // Background Image for Title Slides
                    if (slide.image && slide.layout === 'title-slide') {
                        const bg = document.createElement('div');
                        bg.className = 'slide-bg-image';
                        bg.style.backgroundImage = `url('${slide.image}')`;
                        viewer.appendChild(bg);
                    }

                    viewer.appendChild(el);

                    // Initialize any simulations
                    if (slide.simulation) {
                        this.initSimulation(slide.simulation, el.querySelector('.simulation-container'));
                    }

                    // Syntax Highlighting
                    // Syntax Highlighting
                    if (window.hljs) {
                        hljs.highlightAll();
                    }

                    // Typeset Math
                    // Typeset Math
                    if (window.MathJax && window.MathJax.typesetPromise) {
                        MathJax.typesetPromise().catch(err => console.warn('MathJax error:', err));
                    }

                    viewer.style.opacity = 1;
                }, 150);
            },

            getLayoutHTML(slide) {
                switch (slide.layout) {
                    case 'title-slide':
                        return `
                            <h1>${slide.title}</h1>
                            <h2>${slide.subtitle || ''}</h2>
                            <div class="footer">${slide.footer || ''}</div>
                        `;
                    case 'content-image':
                        return `
                            <div class="layout-split ratio-55-45">
                                <div class="col-text">
                                    <h2>${slide.title}</h2>
                                    <div>${slide.content}</div>
                                </div>
                                <div class="col-visual">
                                    <img src="${slide.image}" alt="Slide Visual">
                                </div>
                            </div>
                        `;
                    case 'content-simulation':
                        return `
                            <div class="layout-split ratio-40-60">
                                <div class="col-text">
                                    <h2>${slide.title}</h2>
                                    <div>${slide.content}</div>
                                </div>
                                <div class="col-visual">
                                    <div class="simulation-container" id="sim-${slide.id}"></div>
                                </div>
                            </div>
                        `;
                    case 'full-simulation':
                        return `
                            <div class="layout-full-simulation">
                                <div class="overlay-title">
                                    <h2>${slide.title}</h2>
                                </div>
                                <div class="simulation-container" id="sim-${slide.id}"></div>
                            </div>
                        `;
                    case 'comparison':
                        return `
                            <div class="layout-comparison">
                                <div class="col-compare">
                                    ${slide.content_left || '<!-- Left Content -->'}
                                </div>
                                <div class="divider"></div>
                                <div class="col-compare">
                                    ${slide.content_right || '<!-- Right Content -->'}
                                </div>
                            </div>
                        `;
                    case 'three-column':
                        return `
                            <h2>${slide.title}</h2>
                            <div class="layout-comparison" style="grid-template-columns: 1fr 1px 1fr 1px 1fr;">
                                <div class="col-compare">
                                    ${slide.content_left}
                                </div>
                                <div class="divider"></div>
                                <div class="col-compare">
                                    ${slide.content_center}
                                </div>
                                <div class="divider"></div>
                                <div class="col-compare">
                                    ${slide.content_right}
                                </div>
                            </div>
                        `;
                    case 'section-break':
                        return `
                            <div class="layout-section-break">
                                <h1>${slide.title}</h1>
                                <h2>${slide.subtitle || ''}</h2>
                                <p>${slide.description || ''}</p>
                            </div>
                        `;
                    case 'code-slide':
                        return `
                            <div class="layout-split ratio-40-60">
                                <div class="col-text">
                                    <h2>${slide.title}</h2>
                                    <div>${slide.content}</div>
                                </div>
                                <div class="col-visual" style="align-items: flex-start; overflow: auto; background: var(--bg-surface);">
                                    <pre><code class="language-python">${slide.code || ''}</code></pre>
                                </div>
                            </div>
                        `;
                    default:
                        return `<h1>${slide.title}</h1>`;
                }
            },

            initSimulation(simId, container) {
                if (!container) return;
                console.log(`Initializing simulation: ${simId} `);
                container.innerHTML = '';

                // Use requestAnimationFrame to ensure the container has been laid out 
                // and has correct dimensions before we create the SVG
                requestAnimationFrame(() => {
                    requestAnimationFrame(() => {
                        if (SIMULATIONS[simId]) {
                            SIMULATIONS[simId](container);
                        } else {
                            container.innerHTML = `<div style="display:flex;justify-content:center;align-items:center;height:100%;color:var(--text-secondary)">Simulation ${simId} Placeholder</div>`;
                        }
                    });
                });
            },

            updateProgress() {
                const percent = ((state.currentSlide + 1) / SLIDES.length) * 100;
                this.dom.progressBar.style.width = `${percent}% `;
                this.dom.counter.innerText = `${state.currentSlide + 1} / ${SLIDES.length}`;
            },

            updateNotes() {
                const slide = SLIDES[state.currentSlide];
                this.dom.notesContent.innerText = slide.notes || "No notes for this slide.";
            },

            toggleFullscreen() {
                if (!document.fullscreenElement) {
                    document.documentElement.requestFullscreen();
                } else {
                    if (document.exitFullscreen) {
                        document.exitFullscreen();
                    }
                }
            },

            toggleNotes() {
                state.notesVisible = !state.notesVisible;
                if (state.notesVisible) {
                    this.dom.notesPanel.classList.add('visible');
                } else {
                    this.dom.notesPanel.classList.remove('visible');
                }
            },

            toggleOverview() {
                state.overviewActive = !state.overviewActive;
                if (state.overviewActive) {
                    this.dom.overviewGrid.classList.add('active');
                } else {
                    this.dom.overviewGrid.classList.remove('active');
                }
            },

            renderOverview() {
                const grid = this.dom.overviewGrid;
                grid.innerHTML = '';
                SLIDES.forEach((slide, index) => {
                    const thumb = document.createElement('div');
                    thumb.className = 'overview-thumb';
                    if (index === state.currentSlide) thumb.classList.add('current');
                    thumb.innerHTML = `
                        <div class="thumb-num">${index + 1}</div>
                        <div class="thumb-title">${slide.title}</div>
                    `;
                    thumb.addEventListener('click', () => {
                        this.goToSlide(index);
                        this.toggleOverview();
                    });
                    grid.appendChild(thumb);
                });
            },

            toggleGoto(show) {
                if (show) {
                    this.dom.gotoModal.classList.add('active');
                    this.dom.gotoInput.value = '';
                    this.dom.gotoInput.focus();
                } else {
                    this.dom.gotoModal.classList.remove('active');
                }
            },

            submitGoto() {
                const val = parseInt(this.dom.gotoInput.value, 10);
                if (val && val >= 1 && val <= SLIDES.length) {
                    this.goToSlide(val - 1);
                    this.toggleGoto(false);
                }
            }
        };

        // Start App
        window.addEventListener('DOMContentLoaded', () => {
            app.init();

            // Notes panel drag-to-resize
            const dragHandle = document.getElementById('notes-drag-handle');
            const notesPanel = document.getElementById('notes-panel');
            let isDragging = false;
            let startY, startHeight;
            dragHandle.addEventListener('mousedown', (e) => {
                isDragging = true;
                startY = e.clientY;
                startHeight = notesPanel.offsetHeight;
                document.body.style.cursor = 'ns-resize';
                e.preventDefault();
            });
            document.addEventListener('mousemove', (e) => {
                if (!isDragging) return;
                const delta = startY - e.clientY;
                const newHeight = Math.max(100, Math.min(window.innerHeight * 0.8, startHeight + delta));
                notesPanel.style.height = newHeight + 'px';
            });
            document.addEventListener('mouseup', () => {
                if (isDragging) {
                    isDragging = false;
                    document.body.style.cursor = '';
                }
            });
        });

    </script>
</body>

</html>